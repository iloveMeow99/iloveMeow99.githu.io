{"meta":{"title":"Yangyang's Blog","subtitle":"A ship in harbor is safe, but that is not what ships are built for.","description":" Yangyyang 的个人博客，框架 Hexo，主题 Butterfly。Yangyang —— 一个前端。","author":"Yangyang","url":"https://ly980408.github.io","root":"/"},"pages":[{"title":"About ...","date":"2023-11-23T07:09:13.277Z","updated":"2023-11-23T07:09:13.277Z","comments":false,"path":"about/index.html","permalink":"https://ly980408.github.io/about/index.html","excerpt":"","text":".title p{ font-size: 20px;} .content{ padding-left: 15px; font-size: 16px;} 关于我 Yangyang 一个前端 喜欢音乐、游戏 更喜欢敲代码（当然） 关于博客 本博客是基于Hexo搭建的，主题为Butterfly"},{"title":"","date":"2023-11-23T07:47:20.109Z","updated":"2023-11-23T07:47:20.109Z","comments":true,"path":"css/mystyle.css","permalink":"https://ly980408.github.io/css/mystyle.css","excerpt":"","text":"/* 滚动条 */ ::-webkit-scrollbar { width: 8px; height: 8px; } ::-webkit-scrollbar-track { background-color: rgba(73, 177, 245, 0.2); /* border-radius: 2em; */ } ::-webkit-scrollbar-thumb { background-color: #49b1f5; background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.4) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.4) 50%, rgba(255, 255, 255, 0.4) 75%, transparent 75%, transparent); /* border-radius: 2em; */ } ::-webkit-scrollbar-corner { background-color: transparent; } ::-moz-selection { color: #fff; background-color: #49b1f5; } /* 页脚footer */ /* 渐变色滚动动画 */ @-webkit-keyframes Gradient { 0% { background-position: 0 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0 50%; } } @-moz-keyframes Gradient { 0% { background-position: 0 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0 50%; } } @keyframes Gradient { 0% { background-position: 0 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0 50%; } } #footer { background: linear-gradient(-45deg, #ee7752, #ce3e75, #23a6d5, #23d5ab); background-size: 400% 400%; animation: Gradient 20s ease infinite; user-select: none; /* border-top-left-radius: 10px; */ /* border-top-right-radius: 10px; */ }"},{"title":"友情链接","date":"2023-11-23T07:09:13.278Z","updated":"2023-11-23T07:09:13.278Z","comments":true,"path":"link/index.html","permalink":"https://ly980408.github.io/link/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-11-23T07:09:13.277Z","updated":"2023-11-23T07:09:13.277Z","comments":false,"path":"categories/index.html","permalink":"https://ly980408.github.io/categories/index.html","excerpt":"","text":""},{"title":"留下足迹","date":"2023-11-23T07:09:13.279Z","updated":"2023-11-23T07:09:13.279Z","comments":true,"path":"messageboard/index.html","permalink":"https://ly980408.github.io/messageboard/index.html","excerpt":"","text":"有什么想说的 有什么想问的 有什么想吐槽的 在下面留言告诉我吧"},{"title":"热爱生活，热爱音乐","date":"2023-11-23T07:09:13.279Z","updated":"2023-11-23T07:09:13.279Z","comments":true,"path":"music/index.html","permalink":"https://ly980408.github.io/music/index.html","excerpt":"","text":"致敬光叔，致敬经典，致敬童年（博客的主题也叫 Butterfly 哦） var ap = new APlayer({ element: document.getElementById(\"aplayer-imlzvbDw\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Butter-Fly\", author: \"和田光司(わだこうじ)\", url: \"http://music.163.com/song/media/outer/url?id=4940920\", pic: \"https://y.gtimg.cn/music/photo_new/T002R300x300M000003hS7PE1Sk8yu_1.jpg?max_age=2592000\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); IU var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":0,\"mode\":\"random\",\"mutex\":true,\"theme\":\"#e6d0b2\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"삐삐 (BBIBBI)\",\"author\":\"IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=1316563427\",\"pic\":\"https://pic.xiami.net/images/album/img14/196/5bbdc4a4491bc_9841114_1539163300.jpg?x-oss-process=image/quality,q_80/format,jpg\"},{\"title\":\"Blueming\",\"author\":\"IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=1404511131\",\"pic\":\"https://pic.xiami.net/images/album/img67/13/5dd25f4b8247f_679267_1574068043.jpg?x-oss-process=image/quality,q_80/format,jpg\"},{\"title\":\"Celebrity\",\"author\":\"IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=1815389717\",\"pic\":\"http://p1.music.126.net/5G0jdorNO1vRvJDys7kESw==/109951165669210873.jpg?param=177y177\"},{\"title\":\"Love poem\",\"author\":\"IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=1400436688\",\"pic\":\"https://pic.xiami.net/images/album/img9/60/5dbbf5e4db403_3020209_1572599268.jpg?x-oss-process=image/quality,q_80/format,jpg\"},{\"title\":\"囍帖街 (Live)\",\"author\":\"IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=35847131\",\"pic\":\"https://pic.xiami.net/images/album/img22/56822/21003906211474253302.jpeg?x-oss-process=image/quality,q_80/format,jpg\"},{\"title\":\"봄 사랑 벚꽃 말고 (除了春天 爱情和樱花)\",\"author\":\"High4 / IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=28391219\",\"pic\":\"https://pic.xiami.net/images/album/img82/1895391682/2970987581402380352.jpg?x-oss-process=image/quality,q_80/format,jpg\"}]}; options.element = document.getElementById(\"aplayer-OloUlTSs\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);"},{"title":"标签","date":"2020-02-26T12:44:18.000Z","updated":"2023-11-23T07:09:13.279Z","comments":false,"path":"tags/index.html","permalink":"https://ly980408.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"React最佳实践（未完整，持续更新）","slug":"React最佳实践","date":"2023-04-30T05:14:00.000Z","updated":"2023-11-23T07:54:30.181Z","comments":true,"path":"posts/29633316/","link":"","permalink":"https://ly980408.github.io/posts/29633316/","excerpt":"","text":"React最佳实践 – 2022年编写更好的React代码的技巧 🌠 本文非原创，为原文的中文翻译版 📖 原文地址：https://www.freecodecamp.org/news/best-practices-for-react/ 目录: React 开发者面临的三大挑战 了解 React 的基础 学习如何构建整洁、高性能和可维护的 React 组件 Tips to Help You Write Better React Code – The Cherries on Top Final Words 首先也是最重要的，你应该知道每一个 React 开发者需要去面对的三个主要挑战。这很重要因为当你意识到潜在的挑战时，你将会更加深入地理解这些最佳实践背后的原因。 React 开发者面临的三大挑战⚙️ 可维护性这与可复用性息息相关。在应用程序和组件非常轻量的时候，它们很容易维护。但是，一旦需求开始增长，组件就会变得非常复杂，因此维护性较差。 我经常看到一个有许多不同情况代表不同结果的组件。JSX 充满条件渲染（三元运算符和简单&amp;&amp;运算符），根据条件添加 class names ，或者该组件使用巨大的Switch语句。有许多 props 和 state，每个都会造成不同的结果。 在我看来，这些技术本身并没有错。但是我认为，当组件开始变得较低的可维护以及这些技术变得过度使用时，每个人都应该对自己产生一种感觉。我们将在本文后面学习如何更好地控制这种情况。 问题（我也为此感到内疚）是组件越复杂、结果越不同（多态性），它就越难维护。 老实说，根本原因往往是懒惰、经验不足或时间压力，无法适当地重构组件，使其更易于维护和更整洁。 我看到的另一个关键因素是没有测试或测试很少。我知道，测试不是一个很多开发者喜爱的工作类型，但从长远来看，这确实可以帮助你。测试本身不会是这篇文章的主要话题，所以请留意我关于它的另一篇博客文章。 🧠 扎实理解 React开发人员出现问题的另一个根本原因是对 React 如何在底层工作的基本理解不足。我也曾经这样。 我见过很多人在没有坚实基础的情况下，过快地进入中级或高级概念。但这并不是 React 独有的。这是编程中的一个常见问题。 对 React 没有扎实的理解也会给作为开发人员的您带来问题。我记得当我想使用不同的组件生命周期，但不知道如何实际使用它们时，我感到头疼。所以我不得不后退几步，深入探讨这个话题。 因为我认为这是最重要的事情之一，所以我在下面的博客文章中专门用了整整一章来介绍它。 📈 可扩展性这项挑战与可维护性息息相关。它不仅针对 React，而是通常适用于软件开发中。 我了解到，制作优秀的软件不仅仅是关于 UX（用户体验）、干净的代码模式或聪明的架构。对我来说，软件的质量也会随着它的扩展能力而上升或下降。 对我来说，有很多东西可以提高软件的可扩展性。你将在这篇文章中学习我最重要的技巧。 我认为，当您在设计组件和组织项目结构时考虑到可维护性和可扩展性的话，您不太可能最终出现需要进行重大重构的混乱代码。 好了，现在让我们深入了解一些学习 React 的最佳实践。 了解 React 的基础正如我们在上面简要讨论的那样，表明了基础不仅与学习 React 有关，也与其他技术或编程语言有关。你不能在沙质地基上建造摩天大楼，却期望它坚固。 这对你们中的许多人来说可能是显而易见的，但我见过一些开发人员在没有真正理解基础知识的情况下就跳到了 React 的中级或高级概念中。 一般来说，Javascript 也是如此。我坚信，如果你在 Vanilla Javascript（指原生 JS）方面没有坚实的基础，那么学习 React 是没有意义的。 所以，如果这听起来很熟悉，并且你正在考虑学习 React，但对 Vanilla Javascript 还不太熟悉，那么先花点时间加强 Javascript。这将在未来为你节省很多头痛和时间。 如果你想复习的话，这是一个有用的指南：top JavaScript concepts you need to know before diving into React 但对我来说，仅仅了解基本知识是不够的，去了解 React 的底层原理是强制性的。如果你想成为一名优秀的 React 开发人员（我认为你是这样做的，因为你正在阅读这篇文章），你必须知道你正在使用的工具。这对作为开发人员的你和你的客户都是有益的。 当然，你不可能无所不知，也不应该在这个话题上给自己施加压力。当你遇到实际问题并建立更多的项目时，你会学到越来越多的东西。但有了扎实的知识，你从一开始就全副武装。 好吧，这很有道理。但你可能想知道，为了在 React 中打下坚实的基础，你到底需要知道什么？ 作为最低要求，您应该理解在官方的 React 文档中的主要概念章节。 你应该非常熟悉的另一章是关于Hooks的那一章，因为它们已经成为一种惯例，并且被广泛使用，尤其是在第三方 React 包中。 当然，你可能会更频繁地使用一些，比如useState和useEffect，但理解其他的，比如useMemo、useCallback或useRef也是必不可少的。 还有另一章叫“高级指南”，我一开始并不认为这是强制性的，但我强烈建议您在 React 之旅中掌握这些概念。 和往常一样，当你已经有了一些实践经验时，通常更容易理解高级话题。但你越早了解这些事情越好。 当然，你不应该局限于只关注 React 文档。通过一门涵盖这些基础知识的在线课程，观看教程或阅读其他博客文章，也是打下坚实基础的一部分。所以，测试一下什么最适合你。 如果我不得不选择至少最重要的概念来了解，我会建议： 什么是“状态” 类组件和函数式组件的区别 什么是组件重新渲染，它们是如何工作的？ 如何触发重新渲染？ 不同的组件生命周期以及如何与它们交互 Virtual DOM CSR（客户端渲染）和 SSR（服务器端渲染）一般来说在 React 中的优势 受控组件和非受控组件 状态提升 至少一种全局状态管理技术（Context API、Redux/Toolkit、Recoil） 组件模式（尤其是如何选择正确的模式） 学习如何构建整洁、高性能和可维护的 React 组件我知道——这是每个程序员的梦想（或者至少我希望是这样）。对我来说，这种能力将好的程序员与出色的程序员区分开来。有趣的是，它从来没有真正完成，因为总会有一些需要学习和改进的东西。 遵循这些最佳实践不仅会让你，也会让你的队友更容易做到这点。我见过一些创建了风格指南的开发团队，他们定义了如何编写代码的重要基石。在我看来这是个好主意。 其中一部分是： 使用函数式组件（例如箭头函数） 不要使用内联样式 保持适当的导入结构（第三方导入优先 –&gt; 内部导入在下面） 在提交之前格式化你的代码 等等。 当然，你可以做到非常详细。这取决你的团队。我个人不喜欢十分详细的风格指南，因为我认为作为一名熟练的开发者，你应该保持一些自由，不应该受太多限制。 但是，一般来说，样式指南是一个描述和保持最佳实践的好方法，并确保您的团队在有关某些重要部分时保持一致。我认为这会大大增加团队合作和产出。 让我们来看看创建干净、高性能和可维护的组件的最佳实践是什么。让自己感到舒适，找点东西做笔记，然后享受吧！ 📁 创建合适的文件夹结构在 React 应用程序中组织文件和文件夹对于可维护性和可扩展性是十分必要的。 良好的文件夹结构取决于您的应用程序和团队的大小。因此，这并没有一个普遍的答案。尤其是因为这是一个非常固执己见的话题，也取决于个人喜好。 But over the time, some best practices for different sizes of an application have evolved. This great blog post goes through five different application sizes and introduces good ideas of how to organize your files and folders. Having this in mind when planning or starting your application can make a huge difference on the long run. Don’t over-engineer it, but try your best maintain a proper structure that is best suited for your current application and your team size. 👇 Maintain a structured import orderIf you’ve already got some experience in React, you might have seen files that are bloated with a lot of import statements. They might also be mixed up with external imports from third-party packages and internal imports like other components, util functions, styles and many more. Real World Example (cut): 1234567891011121314151617import React, &#123; useState, useEffect, useCallback &#125; from &quot;react&quot;;import Typography from &quot;@material-ui/core/Typography&quot;;import Divider from &quot;@material-ui/core/Divider&quot;;import Title from &quot;../components/Title&quot;;import Navigation from &quot;../components/Navigation&quot;;import DialogActions from &quot;@material-ui/core/DialogActions&quot;import &#123; getServiceURL &#125; from &#x27;../../utils/getServiceURL&quot;;import Grid from &quot;@material-ui/core/Grid&quot;;import Paragraph from &quot;../components/Paragprah&quot;;import &#123; sectionTitleEnum &#125; from &quot;../../constants&quot;;import &#123; useSelector, useDispatch &#125; from &quot;react-redux&quot;;import Box from &quot;@material-ui/core/Box&quot;;import axios from &#x27;axios&#x27;;import &#123; DatePicker &#125; from &quot;@material-ui/pickers&quot;;import &#123; Formik &#125; from &quot;formik&quot;;import CustomButton from &quot;../components/CustomButton&quot;;... In reality the imports span over 55 lines. You probably recognize the deal here. It’s difficult to distinguish what are all the third-party and the local (internal) imports. They are not grouped and seem to be all over the place. Better Version: 123456789101112131415161718import React, &#123; useState, useEffect, useCallback &#125; from &quot;react&quot;;import &#123; useSelector, useDispatch &#125; from &quot;react-redux&quot;;import &#123; Formik &#125; from &quot;formik&quot;;import axios from &#x27;axios&#x27;;import Typography from &quot;@material-ui/core/Typography&quot;;import Divider from &quot;@material-ui/core/Divider&quot;;import Box from &quot;@material-ui/core/Box&quot;;import DialogActions from &quot;@material-ui/core/DialogActions&quot;;import Grid from &quot;@material-ui/core/Grid&quot;;import &#123; DatePicker &#125; from &quot;@material-ui/pickers&quot;;import &#123; getServiceURL &#125; from &#x27;../../utils/getServiceURL&quot;;import &#123; sectionTitleEnum &#125; from &quot;../../constants&quot;;import CustomButton from &quot;../components/CustomButton&quot;;import Title from &quot;../components/Title&quot;;import Navigation from &quot;../components/Navigation&quot;;import Paragraph from &quot;../components/Paragraph&quot;;... The structure is clearer and it’s very easy to distinguish where the external and internal imports are. Of course you can optimize it more if you are using more named imports (if that’s possible! :) ). That allows you to import all the components that are coming from material-ui all on one line. I’ve seen other developers who like to split the import structure up in three different parts: Built-In (like ‘react’) –&gt; External (third-party node modules) –&gt; Internal. You can manage it every time by yourself or let a linter do the job. Here’s a great article about how to configure your linter for your React app to maintain a proper import structure.","categories":[{"name":"React","slug":"React","permalink":"https://ly980408.github.io/categories/React/"}],"tags":[{"name":"指南","slug":"指南","permalink":"https://ly980408.github.io/tags/%E6%8C%87%E5%8D%97/"},{"name":"React","slug":"React","permalink":"https://ly980408.github.io/tags/React/"},{"name":"最佳实践","slug":"最佳实践","permalink":"https://ly980408.github.io/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}],"author":"Yangyang"},{"title":"Airbnb JavaScript 风格指南(中文版)","slug":"AirbnbJavaScriptStyleGuideCN","date":"2023-02-08T02:08:00.000Z","updated":"2023-11-23T07:09:13.272Z","comments":true,"path":"posts/airbnb-javascript-style-guide-cn/","link":"","permalink":"https://ly980408.github.io/posts/airbnb-javascript-style-guide-cn/","excerpt":"","text":"本文非原创，内容节选自：https://github.com/lin-123/javascript原文为 airbnb/javascript 的中文翻译版 Airbnb JavaScript 风格指南() {_使用 JavaScript 最合理的方式_。 目录 类型 引用 对象 数组 解构 字符串 函数 箭头函数 类与构造函数 模块 迭代器与生成器 属性 变量 提升 比较运算符与相等 块 控制语句 注释 空格 逗号 分号 类型转换与强制转换 命名规范 Get-Set 访问器 事件 jQuery ECMAScript 5 兼容性 ECMAScript 6+ (ES 2015+) 风格 标准库 测试 性能 类型 1.1 基本类型: 你可以直接获取到基本类型的值 string number boolean null undefined symbol bigint 123456const foo = 1;let bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 由于 Symbols 和 BigInts 不能被正确的 polyfill。所以不应在不能原生支持这些类型的环境或浏览器中使用他们。 1.2 复杂类型: 复杂类型赋值是获取到他的引用的值。 object array function 123456const foo = [1, 2];const bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 ⬆ 回到顶部 引用 2.1 所有的赋值都用 const，避免使用 var。eslint: prefer-const, no-const-assign 为什么？因为这个能确保你不会改变你的初始值，重复引用会导致 bug 并且使代码变得难以理解。 1234567// badvar a = 1;var b = 2;// goodconst a = 1;const b = 2; 2.2 如果你一定要对参数重新赋值，使用 let，而不是 var。eslint: no-var 为什么？因为 let 是块级作用域，而 var 是函数级作用域。 1234567891011// badvar count = 1;if (true) &#123; count += 1;&#125;// good, use the let.let count = 1;if (true) &#123; count += 1;&#125; 2.3 注意：let 和 const 都是块级作用域， 而 var 是函数级作用域 123456789// const 和 let 都只存在于它被定义的那个块级作用域。&#123; let a = 1; const b = 1; var c = 1;&#125;console.log(a); // 引用错误console.log(b); // 引用错误console.log(c); // 打印 1 上面的代码里，a 和 b 的定义会报引用错误，这是因为 a 和 b 是块级作用域， 而 c 的作用域是在函数里的。 ⬆ 返回顶部 对象 3.1 使用字面值创建对象。eslint: no-new-object 12345// badconst item = new Object();// goodconst item = &#123;&#125;; 3.2 使用计算属性名创建一个带有动态属性名的对象。 为什么？因为这可以使你在同一个地方定义所有对象属性。 1234567891011121314151617function getKey(k) &#123; return `a key named $&#123;k&#125;`;&#125;// badconst obj = &#123; id: 5, name: &#x27;San Francisco&#x27;,&#125;;obj[getKey(&#x27;enabled&#x27;)] = true;// goodconst obj = &#123; id: 5, name: &#x27;San Francisco&#x27;, [getKey(&#x27;enabled&#x27;)]: true,&#125;; 3.3 用对象方法简写。eslint: object-shorthand 123456789101112131415161718// badconst atom = &#123; value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; value: 1, // 对象的方法 addValue(value) &#123; return atom.value + value; &#125;,&#125;; 3.4 用属性值缩写。eslint: object-shorthand 为什么？这样写更简洁，且可读性更高。 1234567891011const lukeSkywalker = &#x27;Luke Skywalker&#x27;;// badconst obj = &#123; lukeSkywalker: lukeSkywalker,&#125;;// goodconst obj = &#123; lukeSkywalker,&#125;; 3.5 将你的所有缩写放在对象声明的前面。 为什么？因为这样能更方便地知道有哪些属性用了缩写。 12345678910111213141516171819202122const anakinSkywalker = &#x27;Anakin Skywalker&#x27;;const lukeSkywalker = &#x27;Luke Skywalker&#x27;;// badconst obj = &#123; episodeOne: 1, twoJediWalkIntoACantina: 2, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker,&#125;;// goodconst obj = &#123; lukeSkywalker, anakinSkywalker, episodeOne: 1, twoJediWalkIntoACantina: 2, episodeThree: 3, mayTheFourth: 4,&#125;; 3.6 只对那些无效的标示使用引号 &#39;&#39;。eslint: quote-props 为什么？通常我们认为这种方式主观上更易读。不仅优化了代码高亮，而且也更容易被许多 JS 引擎优化。 12345678910111213// badconst bad = &#123; foo: 3, bar: 4, &#x27;data-blah&#x27;: 5,&#125;;// goodconst good = &#123; foo: 3, bar: 4, &#x27;data-blah&#x27;: 5,&#125;; 3.7 不要直接调用 Object.prototype上的方法，如 hasOwnProperty、propertyIsEnumerable、isPrototypeOf。eslint: [no-prototype-builtins](https://eslint.org/docs/rules/no-prototype-builtins) &gt; 为什么？在一些有问题的对象上，这些方法可能会被屏蔽掉，如：`&#123; hasOwnProperty: false &#125;` 或空对象 `Object.create(null)` 123456789101112// badconsole.log(object.hasOwnProperty(key));// goodconsole.log(Object.prototype.hasOwnProperty.call(object, key));// bestconst has = Object.prototype.hasOwnProperty; // 在模块作用域内做一次缓存。console.log(has.call(object, key));/* or */import has from &#x27;has&#x27;; // https://www.npmjs.com/package/hasconsole.log(has(object, key)); 3.8 对象浅拷贝时，更推荐使用扩展运算符（即 ... 运算符），而不是 Object.assign。获取对象指定的几个属性时，用对象的 rest 解构运算符（即 ... 运算符）更好。eslint: prefer-object-spread 这一段不太好翻译出来， 大家看下面的例子就懂了。^.^ 12345678910111213141516// very badconst original = &#123; a: 1, b: 2 &#125;;const copy = Object.assign(original, &#123; c: 3 &#125;); // 改了 `original` ಠ_ಠdelete copy.a; // so does this// badconst original = &#123; a: 1, b: 2 &#125;;const copy = Object.assign(&#123;&#125;, original, &#123; c: 3 &#125;); // copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;// good es6 扩展运算符 ...const original = &#123; a: 1, b: 2 &#125;;// 浅拷贝const copy = &#123; ...original, c: 3 &#125;; // copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;// rest 解构运算符const &#123; a, ...noA &#125; = copy; // noA =&gt; &#123; b: 2, c: 3 &#125; ⬆ 返回顶部 数组 4.1 用字面量创建数组。eslint: no-array-constructor 12345// badconst items = new Array();// goodconst items = []; 4.2 用 Array#push 代替直接向数组中添加一个值。 1234567const someStack = [];// badsomeStack[someStack.length] = &#x27;abracadabra&#x27;;// goodsomeStack.push(&#x27;abracadabra&#x27;); 4.3 用扩展运算符做数组浅拷贝，类似上面的对象浅拷贝。 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i += 1) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 4.4 用 ... 运算符而不是 Array.from 来将一个可迭代的对象转换成数组。 1234567const foo = document.querySelectorAll(&#x27;.foo&#x27;);// goodconst nodes = Array.from(foo);// bestconst nodes = [...foo]; 4.5 用 Array.from 将一个类数组对象转成一个数组。 1234567const arrLike = &#123; 0: &#x27;foo&#x27;, 1: &#x27;bar&#x27;, 2: &#x27;baz&#x27;, length: 3 &#125;;// badconst arr = Array.prototype.slice.call(arrLike);// goodconst arr = Array.from(arrLike); 4.6 用 Array.from 而不是 ... 运算符去做 map 遍历。 因为这样可以避免创建一个临时数组。 12345// badconst baz = [...foo].map(bar);// goodconst baz = Array.from(foo, bar); 4.7 在数组方法的回调函数中使用 return 语句。如果函数体由一条返回一个表达式的语句组成，并且这个表达式没有副作用， 这个时候可以忽略 return，详见 8.2。eslint: array-callback-return 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// good[1, 2, 3].map(x =&gt; &#123; const y = x + 1; return x * y;&#125;);// good 函数只有一个语句[1, 2, 3].map(x =&gt; x + 1);// bad - 没有返回值， 因为在第一次迭代后 acc 就变成 undefined 了[ [0, 1], [2, 3], [4, 5],].reduce((acc, item, index) =&gt; &#123; const flatten = acc.concat(item);&#125;);// good[ [0, 1], [2, 3], [4, 5],].reduce((acc, item, index) =&gt; &#123; const flatten = acc.concat(item); return flatten;&#125;);// badinbox.filter(msg =&gt; &#123; const &#123; subject, author &#125; = msg; if (subject === &#x27;Mockingbird&#x27;) &#123; return author === &#x27;Harper Lee&#x27;; &#125; else &#123; return false; &#125;&#125;);// goodinbox.filter(msg =&gt; &#123; const &#123; subject, author &#125; = msg; if (subject === &#x27;Mockingbird&#x27;) &#123; return author === &#x27;Harper Lee&#x27;; &#125; return false;&#125;); 4.8 如果一个数组有很多行，在数组的 [ 后和 ] 前断行。请看下面示例： 1234567891011121314151617181920212223242526272829303132333435// badconst arr = [ [0, 1], [2, 3], [4, 5],];const objectInArray = [ &#123; id: 1, &#125;, &#123; id: 2, &#125;,];const numberInArray = [1, 2];// goodconst arr = [ [0, 1], [2, 3], [4, 5],];const objectInArray = [ &#123; id: 1, &#125;, &#123; id: 2, &#125;,];const numberInArray = [1, 2]; ⬆ 返回顶部 解构 5.1 用对象的解构赋值来获取和使用对象某个或多个属性值。eslint: prefer-destructuring 为什么？ 解构使您不必为这些属性创建临时引用，并且避免重复引用对象。重复引用对象将造成代码重复、增加阅读次数、提高犯错概率。在一个块级作用域里，解构对象可以在同一个地方给解构字段赋值，而不需要读整个的代码块看它到底用了哪些字段。 123456789101112131415161718// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// goodfunction getFullName(user) &#123; const &#123; firstName, lastName &#125; = user; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125; 5.2 用数组解构。eslint: prefer-destructuring 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 5.3 多个返回值用对象的解构，而不是数组解构。 为什么？你可以在后期添加新的属性或者变换变量的顺序而不会破坏原有的引用。 1234567891011121314151617// badfunction processInput(input) &#123; // 然后就是见证奇迹的时刻 return [left, right, top, bottom];&#125;// 调用者需要想一想返回值的顺序const [left, __, top] = processInput(input);// goodfunction processInput(input) &#123; // oops，奇迹又发生了 return &#123; left, right, top, bottom &#125;;&#125;// 调用者只需要选择他想用的值就好了const &#123; left, top &#125; = processInput(input); ⬆ back to top 字符串 6.1 字符串应使用单引号 &#39;&#39; 。eslint: quotes 12345678// badconst name = &#x27;Capt. Janeway&#x27;;// bad - 模板字符串应该包含插入文字或换行const name = `Capt. Janeway`;// goodconst name = &#x27;Capt. Janeway&#x27;; 6.2 超过 100 个字符的字符串不应该用字符串连接成多行。 为什么？字符串折行增加编写难度且不易被搜索。 12345678910111213141516// badconst errorMessage = &#x27;This is a super long error that was thrown because \\ of Batman. When you stop to think about how Batman had anything to do \\ with this, you would get nowhere \\fast.&#x27;;// badconst errorMessage = &#x27;This is a super long error that was thrown because &#x27; + &#x27;of Batman. When you stop to think about how Batman had anything to do &#x27; + &#x27;with this, you would get nowhere fast.&#x27;;// goodconst errorMessage = &#x27;This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.&#x27;; 6.3 当需要动态生成字符串时，使用模板字符串而不是字符串拼接。eslint: prefer-template template-curly-spacing 为什么？模板字符串更具可读性、多行语法更简洁以及更方便插入变量到字符串里头。 12345678910111213141516171819// badfunction sayHi(name) &#123; return &#x27;How are you, &#x27; + name + &#x27;?&#x27;;&#125;// badfunction sayHi(name) &#123; return [&#x27;How are you, &#x27;, name, &#x27;?&#x27;].join();&#125;// badfunction sayHi(name) &#123; return `How are you, $&#123;name&#125;?`;&#125;// goodfunction sayHi(name) &#123; return `How are you, $&#123;name&#125;?`;&#125; 6.4 永远不要使用 eval()，该方法有太多漏洞。eslint: no-eval 6.5 不要使用不必要的转义字符。eslint: no-useless-escape 为什么？反斜线可读性差，因此仅当必要时才使用它。 12345678// badconst foo = &#x27;\\&#x27;this\\&#x27; is &quot;quoted&quot;&#x27;;// goodconst foo = &#x27;\\&#x27;this\\&#x27; is &quot;quoted&quot;&#x27;;//bestconst foo = `my name is &#x27;$&#123;name&#125;&#x27;`; ⬆ 返回顶部 函数 7.1 使用命名函数表达式而不是函数声明。eslint: func-style 函数表达式： const func = function () {} 函数声明： function func () {} 为什么？函数声明会发生提升，这意味着在一个文件里函数很容易在其被定义之前就被引用了。这样伤害了代码可读性和可维护性。如果你发现一个函数又大又复杂，且这个函数妨碍了这个文件其他部分的理解性，你应当单独把这个函数提取成一个单独的模块。不管这个名字是不是由一个确定的变量推断出来的，别忘了给表达式清晰的命名（这在现代浏览器和类似 babel 编译器中很常见）。这消除了由匿名函数在错误调用栈产生的所有假设。 (讨论) 译者注：这一段可能不是很好理解，简单来说就是使用函数声明会发生提升（即在函数被声明之前就可以使用），使用匿名函数会导致难以追踪错误。这一段英文原文在这。 12345678910111213141516// badfunction foo() &#123; // ...&#125;// badconst foo = function () &#123; // ...&#125;;// good// lexical name distinguished from the variable-referenced invocation(s)// 函数表达式名和声明的函数名是不一样的const short = function longUniqueMoreDescriptiveLexicalFoo() &#123; // ...&#125;; 7.2 把立即执行函数包裹在圆括号里。eslint: wrap-iife 立即执行函数：Immediately Invoked Function expression = IIFE。为什么？一个立即调用的函数表达式是一个单元 - 把它和它的调用者（圆括号）包裹起来，使代码读起来更清晰。另外，在模块化世界里，你几乎用不着 IIFE。 1234// immediately-invoked function expression (IIFE)(function () &#123; console.log(&#x27;Welcome to the Internet. Please follow me.&#x27;);&#125;)(); 7.3 不要在非函数块（if、while 等）内声明函数。把这个函数分配给一个变量。浏览器会允许你这样做，但不同浏览器的解析方式不同，这是一个坏消息。eslint: no-loop-func 7.4 注意：ECMA-262 中对块（block）的定义是： 一系列的语句。但是函数声明不是一个语句， 函数表达式是一个语句。 1234567891011121314// badif (currentUser) &#123; function test() &#123; console.log(&#x27;Nope.&#x27;); &#125;&#125;// goodlet test;if (currentUser) &#123; test = () =&gt; &#123; console.log(&#x27;Yup.&#x27;); &#125;;&#125; 7.5 不要用 arguments 命名参数。他的优先级高于每个函数作用域自带的 arguments 对象，这会导致函数自带的 arguments 值被覆盖。 123456789// badfunction foo(name, options, arguments) &#123; // ...&#125;// goodfunction foo(name, options, args) &#123; // ...&#125; 7.6 不要使用 arguments，用收集参数语法 ... 代替。eslint: prefer-rest-params 为什么？... 明确你想用哪个参数。而且收集参数是真数组，而不是类似数组的 arguments。 12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join(&#x27;&#x27;);&#125;// goodfunction concatenateAll(...args) &#123; return args.join(&#x27;&#x27;);&#125; 7.7 用默认参数语法而不是在函数里对参数重新赋值。 123456789101112131415161718192021// really badfunction handleThings(opts) &#123; // 不！我们不该修改 arguments // 第二：如果 opts 的值为 false, 它会被赋值为 &#123;&#125; // 虽然你想这么写，但是这个会带来一些微妙的 bug。 opts = opts || &#123;&#125;; // ...&#125;// still badfunction handleThings(opts) &#123; if (opts === void 0) &#123; opts = &#123;&#125;; &#125; // ...&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; 7.8 避免默认参数的副作用。 为什么？他会令人迷惑不解，比如下面这个，a 到底等于几，这个需要想一下。 123456789var b = 1;// badfunction count(a = b++) &#123; console.log(a);&#125;count(); // 1count(); // 2count(3); // 3count(); // 3 7.9 把默认参数赋值放在最后。eslint: default-param-last 123456789// badfunction handleThings(opts = &#123;&#125;, name) &#123; // ...&#125;// goodfunction handleThings(name, opts = &#123;&#125;) &#123; // ...&#125; 7.10 不要用函数构造器创建函数。eslint: no-new-func 为什么？以这种方式创建函数将类似于字符串 eval()，存在漏洞。 12345// badvar add = new Function(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;return a + b&#x27;);// still badvar subtract = Function(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;return a - b&#x27;); 7.11 函数定义部分要有空格。eslint: space-before-function-paren space-before-blocks 为什么？统一性好，而且在你添加/删除一个名字的时候不需要添加/删除空格。 12345678// badconst f = function () &#123;&#125;;const g = function () &#123;&#125;;const h = function () &#123;&#125;;// goodconst x = function () &#123;&#125;;const y = function a() &#123;&#125;; 7.12 不要修改参数. eslint: no-param-reassign 为什么？操作参数对象对原始调用者会导致意想不到的副作用。就是不要改参数的数据结构，保留参数原始值和数据结构。 123456789// badfunction f1(obj) &#123; obj.key = 1;&#125;// goodfunction f2(obj) &#123; const key = Object.prototype.hasOwnProperty.call(obj, &#x27;key&#x27;) ? obj.key : 1;&#125; 7.13 不要对参数重新赋值。eslint: no-param-reassign 为什么？参数重新赋值会导致意外行为，尤其是对 arguments。这也会导致优化问题，特别是在 V8 引擎里。 12345678910111213141516171819202122// badfunction f1(a) &#123; a = 1; // ...&#125;function f2(a) &#123; if (!a) &#123; a = 1; &#125; // ...&#125;// goodfunction f3(a) &#123; const b = a || 1; // ...&#125;function f4(a = 1) &#123; // ...&#125; 7.14 使用拓展运算符调用多参数的函数。eslint: prefer-spread 为什么？这样更清晰，你不必提供上下文（即指定 this 值），而且你不能轻易地用 apply 来组成 new。 12345678910111213// badconst x = [1, 2, 3, 4, 5];console.log.apply(console, x);// goodconst x = [1, 2, 3, 4, 5];console.log(...x);// badnew (Function.prototype.bind.apply(Date, [null, 2016, 8, 5]))();// goodnew Date(...[2016, 8, 5]); 7.15 调用或者编写一个包含多个参数的函数的缩进，应该像这个指南里的其他多行代码写法一样——即每行只包含一个参数，每行逗号结尾。 123456789101112131415// badfunction foo(bar, baz, quux) &#123; // ...&#125;// good 缩进不要太过分function foo(bar, baz, quux) &#123; // ...&#125;// badconsole.log(foo, bar, baz);// goodconsole.log(foo, bar, baz); ⬆ 返回顶部 箭头函数 8.1 当你一定要用函数表达式（在回调函数里）的时候，使用箭头函数。 eslint: prefer-arrow-callback, arrow-spacing 为什么？箭头函数中的 this 与定义该函数的上下文中的 this 一致，这通常才是你想要的。而且箭头函数是更简洁的语法。 什么时候不用箭头函数：如果你的函数逻辑较复杂，你应该把它单独写入一个命名函数里头。 1234567891011// bad[1, 2, 3].map(function (x) &#123; const y = x + 1; return x * y;&#125;);// good[1, 2, 3].map(x =&gt; &#123; const y = x + 1; return x * y;&#125;); 8.2 如果函数体由一个没有副作用的 表达式 语句组成，删除大括号和 return。否则，使用大括号和 return 语句。 eslint: arrow-parens, arrow-body-style 为什么？语法糖，当多个函数链在一起的时候好读。 1234567891011121314151617181920212223242526272829303132// bad[1, 2, 3].map(number =&gt; &#123; const nextNumber = number + 1; `A string containing the $&#123;nextNumber&#125;.`;&#125;);// good[1, 2, 3].map(number =&gt; `A string containing the $&#123;number + 1&#125;.`);// good[1, 2, 3].map(number =&gt; &#123; const nextNumber = number + 1; return `A string containing the $&#123;nextNumber&#125;.`;&#125;);// good[1, 2, 3].map((number, index) =&gt; (&#123; [index]: number,&#125;));// 没有明显的 return 语句，可能存在副作用。function foo(callback) &#123; const val = callback(); if (val === true) &#123; // 当 callback 返回 true 时... &#125;&#125;let bool = false;// badfoo(() =&gt; (bool = true)); // goodfoo(() =&gt; {bool = true;}); 1 8.3 如果表达式涉及多行，把他包裹在圆括号里以提高可读性。 为什么？这样能清晰地显示函数的开始位置和结束位置。 123456789101112131415// bad[&#x27;get&#x27;, &#x27;post&#x27;, &#x27;put&#x27;].map(httpMethod =&gt; Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod ));// good[&#x27;get&#x27;, &#x27;post&#x27;, &#x27;put&#x27;].map(httpMethod =&gt; Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod )); 8.4 在箭头函数参数两头，总是使用小括号包裹住参数，这样做使代码更清晰且一致. eslint: arrow-parens 为什么？当你想要添加或删除参数时改动最小。 1234567891011121314151617// bad[1, 2, 3].map(x =&gt; x * x);// good[1, 2, 3].map(x =&gt; x * x);// bad[1, 2, 3].map( number =&gt; `A long string with the $&#123;number&#125;. It’s so long that we don’t want it to take up space on the .map line!`);// good[1, 2, 3].map( number =&gt; `A long string with the $&#123;number&#125;. It’s so long that we don’t want it to take up space on the .map line!`); // bad[1, 2, 3].map(x =&gt; {const y = x + 1;return x * y;}); // good[1, 2, 3].map((x) =&gt; {const y = x + 1;return x * y;}); 1 8.5 避免箭头函数（=&gt;）和比较操作符（&lt;=, &gt;=）混淆. eslint: no-confusing-arrow 1234567891011121314151617// badconst itemHeight = item =&gt; item.height &lt;= 256 ? item.largeSize : item.smallSize;// badconst itemHeight = item =&gt; item.height &gt;= 256 ? item.largeSize : item.smallSize;// goodconst itemHeight = item =&gt; item.height &lt;= 256 ? item.largeSize : item.smallSize;// goodconst itemHeight = item =&gt; &#123; const &#123; height, largeSize, smallSize &#125; = item; return height &lt;= 256 ? largeSize : smallSize;&#125;; 8.6 使箭头函数体有一个清晰的返回。 eslint: implicit-arrow-linebreak 123456789// badfoo =&gt; bar;foo =&gt; bar;// goodfoo =&gt; bar;foo =&gt; bar;foo =&gt; bar; ⬆ 返回顶部 类与构造函数 9.1 使用 class 语法。避免直接操作 prototype。 为什么？class 语法更简洁更易理解。 123456789101112131415161718192021// badfunction Queue(contents = []) &#123; this.queue = [...contents];&#125;Queue.prototype.pop = function () &#123; const value = this.queue[0]; this.queue.splice(0, 1); return value;&#125;;// goodclass Queue &#123; constructor(contents = []) &#123; this.queue = [...contents]; &#125; pop() &#123; const value = this.queue[0]; this.queue.splice(0, 1); return value; &#125;&#125; 9.2 用 extends 实现继承。 为什么？它是一种内置的方法来继承原型功能而不破坏 instanceof。 12345678910111213141516// badconst inherits = require(&#x27;inherits&#x27;);function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function () &#123; return this.queue[0];&#125;;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this.queue[0]; &#125;&#125; 9.3 方法可以返回 this 来实现链式调用。 123456789101112131415161718192021222324252627282930// badJedi.prototype.jump = function () &#123; this.jumping = true; return true;&#125;;Jedi.prototype.setHeight = function (height) &#123; this.height = height;&#125;;const luke = new Jedi();luke.jump(); // =&gt; trueluke.setHeight(20); // =&gt; undefined// goodclass Jedi &#123; jump() &#123; this.jumping = true; return this; &#125; setHeight(height) &#123; this.height = height; return this; &#125;&#125;const luke = new Jedi();luke.jump().setHeight(20); 9.4 自己写 toString() 方法是可以的，但需要保证它可以正常工作且没有副作用。 12345678910111213class Jedi &#123; constructor(options = &#123;&#125;) &#123; this.name = options.name || &#x27;no name&#x27;; &#125; getName() &#123; return this.name; &#125; toString() &#123; return `Jedi - $&#123;this.getName()&#125;`; &#125;&#125; 9.5 如果没有特别定义，类有默认的构造方法。一个空的构造函数或只是代表父类的构造函数是不需要写的。 eslint: no-useless-constructor 123456789101112131415161718192021222324// badclass Jedi &#123; constructor() &#123;&#125; getName() &#123; return this.name; &#125;&#125;// badclass Rey extends Jedi &#123; // 这种构造函数是不需要写的 constructor(...args) &#123; super(...args); &#125;&#125;// goodclass Rey extends Jedi &#123; constructor(...args) &#123; super(...args); this.name = &#x27;Rey&#x27;; &#125;&#125; 9.6 避免重复定义类成员。eslint: no-dupe-class-members 为什么？重复定义类成员只会使用最后一个被定义的 —— 重复本身也是一个 bug. 1234567891011121314151617181920212223// badclass Foo &#123; bar() &#123; return 1; &#125; bar() &#123; return 2; &#125;&#125;// goodclass Foo &#123; bar() &#123; return 1; &#125;&#125;// goodclass Foo &#123; bar() &#123; return 2; &#125;&#125; 9.7 除非外部库或框架需要使用特定的非静态方法，否则类方法应该使用 this 或被写成静态方法。作为一个实例方法表明它应该根据实例的属性有不同的行为。eslint: class-methods-use-this 123456789101112131415161718192021222324252627// badclass Foo &#123; bar() &#123; console.log(&#x27;bar&#x27;); &#125;&#125;// good - this 被使用了class Foo &#123; bar() &#123; console.log(this.bar); &#125;&#125;// good - constructor 不一定要使用 thisclass Foo &#123; constructor() &#123; // ... &#125;&#125;// good - 静态方法不需要使用 thisclass Foo &#123; static bar() &#123; console.log(&#x27;bar&#x27;); &#125;&#125; ⬆ 返回顶部 模块 10.1 使用（import/export）模块而不是非标准的模块系统。你可以随时转到你喜欢的模块系统。 为什么？模块化是未来，让我们现在就开启未来吧。 1234567891011// badconst AirbnbStyleGuide = require(&#x27;./AirbnbStyleGuide&#x27;);module.exports = AirbnbStyleGuide.es6;// okimport AirbnbStyleGuide from &#x27;./AirbnbStyleGuide&#x27;;export default AirbnbStyleGuide.es6;// bestimport &#123; es6 &#125; from &#x27;./AirbnbStyleGuide&#x27;;export default es6; 10.2 不要用 import 通配符， 即 * 这种方式。 为什么？这确保你有单个默认的导出。 12345// badimport * as AirbnbStyleGuide from &#x27;./AirbnbStyleGuide&#x27;;// goodimport AirbnbStyleGuide from &#x27;./AirbnbStyleGuide&#x27;; 10.3 不要直接从 import 中直接 export。 为什么？虽然只写一行很简洁，但是使用明确 import 和明确的 export 来保证一致性。 12345678// bad// filename es6.jsexport &#123; es6 as default &#125; from &#x27;./AirbnbStyleGuide&#x27;;// good// filename es6.jsimport &#123; es6 &#125; from &#x27;./AirbnbStyleGuide&#x27;;export default es6; 10.4 一个路径只 import 一次。eslint: no-duplicate-imports 为什么？多行导入同一路径将使代码变得难以维护。 12345678910// badimport foo from &#x27;foo&#x27;;// … 其他导入 … //import &#123; named1, named2 &#125; from &#x27;foo&#x27;;// goodimport foo, &#123; named1, named2 &#125; from &#x27;foo&#x27;;// goodimport foo, &#123; named1, named2 &#125; from &#x27;foo&#x27;; 10.5 不要导出可变的东西。eslint: import/no-mutable-exports 为什么？变化通常都是需要避免，特别是当你要输出可变的绑定。虽然在某些场景下可能需要这种技术，但总的来说应该导出常量。 1234567// badlet foo = 3;export &#123; foo &#125;;// goodconst foo = 3;export &#123; foo &#125;; 10.6 在一个单一导出模块里，用 export default 更好。eslint: import/prefer-default-export 为什么？鼓励使用更多文件，每个文件只导出一次，这样可读性和可维护性更好。 12345// badexport function foo() &#123;&#125;// goodexport default function foo() &#123;&#125; 10.7 把 import 放在其他所有语句之前。eslint: import/first 为什么？因为 import 会被提升到代码最前面运行，因此将他们放在最前面以防止发生意外行为。 1234567891011// badimport foo from &#x27;foo&#x27;;foo.init();import bar from &#x27;bar&#x27;;// goodimport foo from &#x27;foo&#x27;;import bar from &#x27;bar&#x27;;foo.init(); 10.8 多行 import 应该缩进，就像多行数组和对象字面量一样。eslint: object-curly-newline 为什么？花括号与样式指南中每个其他花括号块遵循相同的缩进规则，逗号也是。 12345// badimport &#123; longNameA, longNameB, longNameC, longNameD, longNameE &#125; from &#x27;path&#x27;;// goodimport &#123; longNameA, longNameB, longNameC, longNameD, longNameE &#125; from &#x27;path&#x27;; 10.9 在 import 语句里不允许 Webpack loader 语法。eslint: import/no-webpack-loader-syntax 为什么？一旦用 Webpack 语法在 import 里会把代码耦合到模块绑定器。最好是在 webpack.config.js 里写 webpack loader 语法 1234567// badimport fooSass from &#x27;css!sass!foo.scss&#x27;;import barCss from &#x27;style!css!bar.css&#x27;;// goodimport fooSass from &#x27;foo.scss&#x27;;import barCss from &#x27;bar.css&#x27;; 10.10 import JavaScript 文件不用包含扩展名eslint: import/extensions 为什么? 使用扩展名重构不友好，而且让模块使用者去了解模块的实现细节是不合适的。 123456789// badimport foo from &#x27;./foo.js&#x27;;import bar from &#x27;./bar.jsx&#x27;;import baz from &#x27;./baz/index.jsx&#x27;;// goodimport foo from &#x27;./foo&#x27;;import bar from &#x27;./bar&#x27;;import baz from &#x27;./baz&#x27;; ⬆ 返回顶部 迭代器与生成器 11.1 不要用迭代器。使用 JavaScript 高级函数代替 for-in、 for-of。eslint: no-iterator no-restricted-syntax 为什么？这强调了我们不可变的规则。 处理返回值的纯函数比处理副作用更容易。 用数组的这些迭代方法： map() / every() / filter() / find() / findIndex() / reduce() / some() / … , 用对象的这些方法 Object.keys() / Object.values() / Object.entries() 去产生一个数组，这样你就能去遍历对象了。 1234567891011121314151617181920212223242526272829303132const numbers = [1, 2, 3, 4, 5];// badlet sum = 0;for (let num of numbers) &#123; sum += num;&#125;sum === 15;// goodlet sum = 0;numbers.forEach(num =&gt; (sum += num));sum === 15;// best (use the functional force)const sum = numbers.reduce((total, num) =&gt; total + num, 0);sum === 15;// badconst increasedByOne = [];for (let i = 0; i &lt; numbers.length; i++) &#123; increasedByOne.push(numbers[i] + 1);&#125;// goodconst increasedByOne = [];numbers.forEach(num =&gt; &#123; increasedByOne.push(num + 1);&#125;);// best (keeping it functional)const increasedByOne = numbers.map(num =&gt; num + 1); 11.2 现在暂时不要使用生成器。 为什么？生成器目前不能很好地转换为 ES5 语法。 11.3 如果你一定要用生成器，或者你忽略 我们的建议，请确保它们的函数标志空格是得当的。eslint: generator-star-spacing 为什么？function 和 * 是同一概念关键字 - *不是function的修饰符，function* 是一个和function 不一样的独特结构。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// badfunction* foo() &#123; // ...&#125;// badconst bar = function* () &#123; // ...&#125;;// badconst baz = function* () &#123; // ...&#125;;// badconst quux = function* () &#123; // ...&#125;;// badfunction* foo() &#123; // ...&#125;// badfunction* foo() &#123; // ...&#125;// very badfunction* foo() &#123; // ...&#125;// very badconst wat = function* () &#123; // ...&#125;;// goodfunction* foo() &#123; // ...&#125;// goodconst foo = function* () &#123; // ...&#125;; ⬆ 返回顶部 属性 12.1 访问属性时使用点符号。eslint: dot-notation 12345678910const luke = &#123; jedi: true, age: 28,&#125;;// badconst isJedi = luke[&#x27;jedi&#x27;];// goodconst isJedi = luke.jedi; 12.2 当使用变量获取属性时用方括号 []。 12345678910const luke = &#123; jedi: true, age: 28,&#125;;function getProp(prop) &#123; return luke[prop];&#125;const isJedi = getProp(&#x27;jedi&#x27;); 12.3 做幂运算时用幂操作符 ** 。eslint: no-restricted-properties. 12345// badconst binary = Math.pow(2, 10);// goodconst binary = 2 ** 10; ⬆ 返回顶部 变量 13.1 使用 const 或 let 声明变量。不这样做会导致全局变量。我们想要避免污染全局命名空间。地球超人也这样警告我们（译者注：可能是一个冷笑话）。 eslint: no-undef prefer-const 12345// badsuperPower = new SuperPower();// goodconst superPower = new SuperPower(); 13.2 为每个变量声明都用一个 const 或 let。eslint: one-var 为什么？这种方式很容易去声明新的变量，你不用去考虑把 ; 调换成 ,，或者引入一个只有标点的不同的变化（译者注：这里说的应该是在 Git 提交代码时显示的变化）。这种做法也可以是你在调试的时候单步每个声明语句，而不是一下跳过所有声明。 123456789101112131415// badconst items = getItems(), goSportsTeam = true, dragonball = &#x27;z&#x27;;// bad// （与前面的比较，找一找错误）const items = getItems(), goSportsTeam = true;dragonball = &#x27;z&#x27;;// goodconst items = getItems();const goSportsTeam = true;const dragonball = &#x27;z&#x27;; 13.3 把const 和 let 分别放一起。 为什么？在你需要分配一个新的变量，而这个变量依赖之前分配过的变量的时候，这种做法是有帮助的。 1234567891011121314151617181920// badlet i, len, dragonball, items = getItems(), goSportsTeam = true;// badlet i;const items = getItems();let dragonball;const goSportsTeam = true;let len;// goodconst goSportsTeam = true;const items = getItems();let dragonball;let i;let length; 13.4 在你需要的地方声明变量，但是要放在合理的位置。 为什么？let 和 const 都是块级作用域而不是函数级作用域。 1234567891011121314151617181920212223242526272829303132// bad - 不必要的函数调用。function checkName(hasName) &#123; const name = getName(); if (hasName === &#x27;test&#x27;) &#123; return false; &#125; if (name === &#x27;test&#x27;) &#123; this.setName(&#x27;&#x27;); return false; &#125; return name;&#125;// goodfunction checkName(hasName) &#123; if (hasName === &#x27;test&#x27;) &#123; return false; &#125; // 在需要的时候分配 const name = getName(); if (name === &#x27;test&#x27;) &#123; this.setName(&#x27;&#x27;); return false; &#125; return name;&#125; 13.5 不要使用链式声明变量。 eslint: no-multi-assign 为什么？链式声明变量会创建隐式全局变量。 123456789101112131415161718192021222324// bad(function example() &#123; // JavaScript 将这一段解释为 // let a = ( b = ( c = 1 ) ); // let 只对变量 a 起作用; 变量 b 和 c 都变成了全局变量 let a = (b = c = 1);&#125;)();console.log(a); // undefinedconsole.log(b); // 1console.log(c); // 1// good(function example() &#123; let a = 1; let b = a; let c = a;&#125;)();console.log(a); // undefinedconsole.log(b); // undefinedconsole.log(c); // undefined// `const` 也是如此 13.6 不要使用一元自增自减运算符（++， --）. eslint no-plusplus 为什么？根据 eslint 文档，一元增量和减量语句受到自动分号插入的影响，并且可能会导致应用程序中的值递增或递减的静默错误。 使用 num + = 1 而不是 num ++ 或 num ++ 语句也是含义清晰的。 禁止一元增量和减量语句还会阻止您无意地预增/预减值，这也会导致程序出现意外行为。 1234567891011121314151617181920212223242526// badconst array = [1, 2, 3];let num = 1;num++;--num;let sum = 0;let truthyCount = 0;for (let i = 0; i &lt; array.length; i++) &#123; let value = array[i]; sum += value; if (value) &#123; truthyCount++; &#125;&#125;// goodconst array = [1, 2, 3];let num = 1;num += 1;num -= 1;const sum = array.reduce((a, b) =&gt; a + b, 0);const truthyCount = array.filter(Boolean).length; 13.7 在赋值的时候避免在 = 前/后换行。 如果你的赋值语句超出 max-len，那就用小括号把这个值包起来再换行。eslint operator-linebreak. 为什么？在 = 附近换行容易混淆这个赋值语句。 1234567891011// badconst foo = superLongLongLongLongLongLongLongLongFunctionName();// badconst foo = &#x27;superLongLongLongLongLongLongLongLongString&#x27;;// goodconst foo = superLongLongLongLongLongLongLongLongFunctionName();// goodconst foo = &#x27;superLongLongLongLongLongLongLongLongString&#x27;; 13.8 不允许有未使用的变量。eslint: no-unused-vars 为什么？一个声明了但未使用的变量更像是由于重构未完成产生的错误。这种在代码中出现的变量会使阅读者迷惑。 12345678910111213141516171819202122232425262728293031// badvar some_unused_var = 42;// 写了没用var y = 10;y = 5;// 变量改了自己的值，也没有用这个变量var z = 0;z = z + 1;// 参数定义了但未使用function getX(x, y) &#123; return x;&#125;// goodfunction getXPlusY(x, y) &#123; return x + y;&#125;var x = 1;var y = a + 2;alert(getXPlusY(x, y));// &#x27;type&#x27; 即使没有使用也可以可以被忽略， 因为这个有一个 rest 取值的属性。// 这是从对象中抽取一个忽略特殊字段的对象的一种形式var &#123; type, ...coords &#125; = data;// &#x27;coords&#x27; 现在就是一个没有 &#x27;type&#x27; 属性的 &#x27;data&#x27; 对象 ⬆ 返回顶部 提升 14.1 var 声明会被提前到离他最近的作用域的最前面，但是它的赋值语句并没有提前。const 和 let 被赋予了新的概念 暂时性死区 (TDZ)。 重要的是要知道为什么 typeof 不再安全。 1234567891011121314151617181920212223242526// 我们知道这个不会工作，假设没有定义全局的 notDefinedfunction example() &#123; console.log(notDefined); // =&gt; throws a ReferenceError&#125;// 在你引用的地方之后声明一个变量，他会正常输出是因为变量提升。// 注意： declaredButNotAssigned 的值 true 没有被提升。function example() &#123; console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true;&#125;// 解释器把变量声明提升到作用域最前面，// 可以重写成如下例子， 二者意义相同。function example() &#123; let declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true;&#125;// 用 const，let就不一样了。function example() &#123; console.log(declaredButNotAssigned); // =&gt; throws a ReferenceError console.log(typeof declaredButNotAssigned); // =&gt; throws a ReferenceError const declaredButNotAssigned = true;&#125; 14.2 匿名函数表达式和 var 情况相同。 12345678910function example() &#123; console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; TypeError anonymous is not a function // 译者注，不管后面是函数、数字还是字符串，都是一样的，总结就是实际代码中最好不要用 var。 var anonymous = function () &#123; console.log(&#x27;anonymous function expression&#x27;); &#125;;&#125; 14.3 已命名函数表达式提升他的变量名，不是函数名或函数体。 12345678910111213141516171819202122function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function superPower(); // =&gt; ReferenceError superPower is not defined var named = function superPower() &#123; console.log(&#x27;Flying&#x27;); &#125;;&#125;// 函数名和变量名一样是也如此。function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function var named = function named() &#123; console.log(&#x27;named&#x27;); &#125;;&#125; 14.4 函数声明则提升了函数名和函数体。 1234567function example() &#123; superPower(); // =&gt; Flying function superPower() &#123; console.log(&#x27;Flying&#x27;); &#125;&#125; 详情请见 JavaScript Scoping &amp; Hoisting by Ben Cherry. ⬆ 返回顶部 比较运算符与相等 15.1 用 === 和 !== 而不是 == 和 !=. eslint: eqeqeq 15.2 条件语句如 if 语句使用强制 ToBoolean 抽象方法来计算它们的表达式，并且始终遵循以下简单规则： Objects 计算成 true Undefined 计算成 false Null 计算成 false Booleans 计算成 the value of the boolean Numbers +0, -0, or NaN 计算成 false 其他 true Strings &#39;&#39; 计算成 false 其他 true 1234if ([0] &amp;&amp; []) &#123; // true // 数组（即使是空数组）是对象，对象会计算成 true&#125; 15.3 布尔值要用缩写，而字符串和数字要明确使用比较操作符。 1234567891011121314151617181920212223242526272829// badif (isValid === true) &#123; // ...&#125;// goodif (isValid) &#123; // ...&#125;// badif (name) &#123; // ...&#125;// goodif (name !== &#x27;&#x27;) &#123; // ...&#125;// badif (collection.length) &#123; // ...&#125;// goodif (collection.length &gt; 0) &#123; // ...&#125; 15.4 更多信息请见 Angus Croll 的 Truth Equality and JavaScript。 15.5 在 case 和 default 分句里用大括号创建一块包含词法声明的区域（例如：let、const、function 和 class）。eslint rules: no-case-declarations. 为什么？词法声明在整个 switch 的代码块里都可见，但是只有当其被分配后才会初始化，仅当这个 case 被执行时才被初始化。当多个 case 分句试图定义同一个对象时就会出现问题。 12345678910111213141516171819202122232425262728293031323334353637383940// badswitch (foo) &#123; case 1: let x = 1; break; case 2: const y = 2; break; case 3: function f() &#123; // ... &#125; break; default: class C &#123;&#125;&#125;// goodswitch (foo) &#123; case 1: &#123; let x = 1; break; &#125; case 2: &#123; const y = 2; break; &#125; case 3: &#123; function f() &#123; // ... &#125; break; &#125; case 4: bar(); break; default: &#123; class C &#123;&#125; &#125;&#125; 15.6 三元表达式不应该嵌套，通常是单行表达式。eslint rules: no-nested-ternary 123456789101112// badconst foo = maybe1 &gt; maybe2 ? &#x27;bar&#x27; : value1 &gt; value2 ? &#x27;baz&#x27; : null;// betterconst maybeNull = value1 &gt; value2 ? &#x27;baz&#x27; : null;const foo = maybe1 &gt; maybe2 ? &#x27;bar&#x27; : maybeNull;// bestconst maybeNull = value1 &gt; value2 ? &#x27;baz&#x27; : null;const foo = maybe1 &gt; maybe2 ? &#x27;bar&#x27; : maybeNull; 15.7 避免不必要的三元表达式。eslint rules: no-unneeded-ternary 123456789// badconst foo = a ? a : b;const bar = c ? true : false;const baz = c ? false : true;// goodconst foo = a || b;const bar = !!c;const baz = !c; 15.8 用圆括号来组合多种操作符。唯一里的例外就是像 +, -, 和 ** 这种优先级容易理解的运算符。我们还是建议把 / * 放到小括号里， 因为他们混用的时候优先级容易有歧义。 eslint: no-mixed-operators 为什么？这提高了可读性，并且明确了开发者的意图。 12345678910111213141516171819202122232425262728// badconst foo = (a &amp;&amp; b &lt; 0) || c &gt; 0 || d + 1 === 0;// badconst bar = a ** b - (5 % d);// bad// 别人会陷入(a || b) &amp;&amp; c 的迷惑中if (a || (b &amp;&amp; c)) &#123; return d;&#125;// badconst bar = a + (b / c) * d;// goodconst foo = (a &amp;&amp; b &lt; 0) || c &gt; 0 || d + 1 === 0;// goodconst bar = a ** b - (5 % d);// goodif (a || (b &amp;&amp; c)) &#123; return d;&#125;// goodconst bar = a + (b / c) * d; ⬆ back to top 块 16.1 用大括号包裹多行代码块。 eslint: nonblock-statement-body-position 1234567891011121314151617181920// badif (test) return false;// goodif (test) return false;// goodif (test) &#123; return false;&#125;// badfunction foo() &#123; return false;&#125;// goodfunction bar() &#123; return false;&#125; 16.2 if 表达式的 else和 if 的右大括号在一行。eslint: brace-style 123456789101112131415// badif (test) &#123; thing1(); thing2();&#125; else &#123; thing3();&#125;// goodif (test) &#123; thing1(); thing2();&#125; else &#123; thing3();&#125; 16.3 如果 if 语句中总是需要用 return 返回，那后续的 else 就不需要写了。 if 块中包含 return， 它后面的 else if 块中也包含了 return， 这个时候就可以把 return 分到多个 if 语句块中。 eslint: no-else-return 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// badfunction foo() &#123; if (x) &#123; return x; &#125; else &#123; return y; &#125;&#125;// badfunction cats() &#123; if (x) &#123; return x; &#125; else if (y) &#123; return y; &#125;&#125;// badfunction dogs() &#123; if (x) &#123; return x; &#125; else &#123; if (y) &#123; return y; &#125; &#125;&#125;// goodfunction foo() &#123; if (x) &#123; return x; &#125; return y;&#125;// goodfunction cats() &#123; if (x) &#123; return x; &#125; if (y) &#123; return y; &#125;&#125;// goodfunction dogs(x) &#123; if (x) &#123; if (z) &#123; return y; &#125; &#125; else &#123; return z; &#125;&#125; ⬆ 返回顶部 控制语句 17.1 当你的控制语句（if, while 等）太长或者超过最大长度限制的时候，把每一个（组）判断条件放在单独一行里。逻辑操作符放在行首。 为什么？把逻辑操作符放在行首是让操作符的对齐方式和链式函数保持一致。这提高了可读性，也让复杂逻辑更清晰。 123456789101112131415161718192021222324252627282930313233343536373839404142// badif ( (foo === 123 || bar === &#x27;abc&#x27;) &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) &#123; thing1();&#125;// badif (foo === 123 &amp;&amp; bar === &#x27;abc&#x27;) &#123; thing1();&#125;// badif (foo === 123 &amp;&amp; bar === &#x27;abc&#x27;) &#123; thing1();&#125;// badif (foo === 123 &amp;&amp; bar === &#x27;abc&#x27;) &#123; thing1();&#125;// goodif (foo === 123 &amp;&amp; bar === &#x27;abc&#x27;) &#123; thing1();&#125;// goodif ( (foo === 123 || bar === &#x27;abc&#x27;) &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) &#123; thing1();&#125;// goodif (foo === 123 &amp;&amp; bar === &#x27;abc&#x27;) &#123; thing1();&#125; 17.2 不要用选择操作符代替控制语句。 1234567// bad!isRunning &amp;&amp; startRunning();// goodif (!isRunning) &#123; startRunning();&#125; ⬆ 返回顶部 注释 18.1 多行注释用 /** ... */。 12345678910111213141516171819202122// bad// make() returns a new element// based on the passed in tag name//// @param &#123;String&#125; tag// @return &#123;Element&#125; elementfunction make(tag) &#123; // ... return element;&#125;// good/** * make() returns a new element * based on the passed-in tag name */function make(tag) &#123; // ... return element;&#125; 18.2 单行注释用 //，将单行注释放在被注释区域上面。如果注释不是在第一行，那么注释前面就空一行。 123456789101112131415161718192021222324252627282930313233// badconst active = true; // is current tab// good// is current tabconst active = true;// badfunction getType() &#123; console.log(&#x27;fetching type...&#x27;); // set the default type to &#x27;no type&#x27; const type = this._type || &#x27;no type&#x27;; return type;&#125;// goodfunction getType() &#123; console.log(&#x27;fetching type...&#x27;); // set the default type to &#x27;no type&#x27; const type = this._type || &#x27;no type&#x27;; return type;&#125;// also goodfunction getType() &#123; // set the default type to &#x27;no type&#x27; const type = this._type || &#x27;no type&#x27;; return type;&#125; 18.3 所有注释开头空一格，方便阅读。eslint: spaced-comment 1234567891011121314151617181920212223242526272829// bad//is current tabconst active = true;// good// is current tabconst active = true;// bad/** *make() returns a new element *based on the passed-in tag name */function make(tag) &#123; // ... return element;&#125;// good/** * make() returns a new element * based on the passed-in tag name */function make(tag) &#123; // ... return element;&#125; 18.4 在你的注释前使用 FIXME 或 TODO 前缀，这有助于其他开发人员快速理解你指出的需要修复的问题， 或者您建议需要实现的问题的解决方案。 这些不同于常规注释，它们是有明确含义的。FIXME：需要修复这个问题或TODO：需要实现的功能。 18.5 用 // FIXME: 给问题做注释。 12345678class Calculator extends Abacus &#123; constructor() &#123; super(); // FIXME: shouldn&#x27;t use a global here total = 0; &#125;&#125; 18.6 用 // TODO: 去注释问题的解决方案。 12345678class Calculator extends Abacus &#123; constructor() &#123; super(); // TODO: total should be configurable by an options param this.total = 0; &#125;&#125; ⬆ 返回顶部 空格 19.1 一个缩进使用两个空格。eslint: indent 1234567891011121314// badfunction foo() &#123;∙∙∙∙const name;&#125;// badfunction bar() &#123;∙const name;&#125;// goodfunction baz() &#123;∙∙const name;&#125; 19.2 在大括号前空一格。eslint: space-before-blocks 123456789101112131415161718192021// badfunction test() &#123; console.log(&#x27;test&#x27;);&#125;// goodfunction test() &#123; console.log(&#x27;test&#x27;);&#125;// baddog.set(&#x27;attr&#x27;, &#123; age: &#x27;1 year&#x27;, breed: &#x27;Bernese Mountain Dog&#x27;,&#125;);// gooddog.set(&#x27;attr&#x27;, &#123; age: &#x27;1 year&#x27;, breed: &#x27;Bernese Mountain Dog&#x27;,&#125;); 19.3 在控制语句（if, while 等）的圆括号前空一格。在函数调用和定义时，参数列表和函数名之间不空格。 eslint: keyword-spacing 12345678910111213141516171819// badif (isJedi) &#123; fight();&#125;// goodif (isJedi) &#123; fight();&#125;// badfunction fight() &#123; console.log(&#x27;Swooosh!&#x27;);&#125;// goodfunction fight() &#123; console.log(&#x27;Swooosh!&#x27;);&#125; 19.4 用空格来隔开运算符。eslint: space-infix-ops 12345// badconst x = y + 5;// goodconst x = y + 5; 19.5 文件结尾空一行。eslint: eol-last 1234// badimport &#123; es6 &#125; from &#x27;./AirbnbStyleGuide&#x27;;// ...export default es6; 12345// badimport &#123; es6 &#125; from &#x27;./AirbnbStyleGuide&#x27;; // ...export default es6;↵↵ 1234// goodimport &#123; es6 &#125; from &#x27;./AirbnbStyleGuide&#x27;; // ...export default es6;↵ 19.6 当出现长的方法链式调用时（&gt;2 个）用缩进。用点开头强调该行是一个方法调用，而不是一个新的语句。eslint: newline-per-chained-call no-whitespace-before-property 1234567891011121314151617181920212223242526272829303132333435363738394041// bad$(&#x27;#items&#x27;).find(&#x27;.selected&#x27;).highlight().end().find(&#x27;.open&#x27;).updateCount();// bad$(&#x27;#items&#x27;).find(&#x27;.selected&#x27;).highlight().end().find(&#x27;.open&#x27;).updateCount();// good$(&#x27;#items&#x27;).find(&#x27;.selected&#x27;).highlight().end().find(&#x27;.open&#x27;).updateCount();// badconst leds = stage .selectAll(&#x27;.led&#x27;) .data(data) .enter() .append(&#x27;svg:svg&#x27;) .classed(&#x27;led&#x27;, true) .attr(&#x27;width&#x27;, (radius + margin) * 2) .append(&#x27;svg:g&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;radius + margin&#125;,$&#123;radius + margin&#125;)`) .call(tron.led);// goodconst leds = stage .selectAll(&#x27;.led&#x27;) .data(data) .enter() .append(&#x27;svg:svg&#x27;) .classed(&#x27;led&#x27;, true) .attr(&#x27;width&#x27;, (radius + margin) * 2) .append(&#x27;svg:g&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;radius + margin&#125;,$&#123;radius + margin&#125;)`) .call(tron.led);// goodconst leds = stage.selectAll(&#x27;.led&#x27;).data(data);const svg = leds.enter().append(&#x27;svg:svg&#x27;);svg.classed(&#x27;led&#x27;, true).attr(&#x27;width&#x27;, (radius + margin) * 2);const g = svg.append(&#x27;svg:g&#x27;);g.attr(&#x27;transform&#x27;, `translate($&#123;radius + margin&#125;,$&#123;radius + margin&#125;)`).call( tron.led); 19.7 在一个代码块后下一条语句前空一行。 12345678910111213141516171819202122232425262728293031323334353637// badif (foo) &#123; return bar;&#125;return baz;// goodif (foo) &#123; return bar;&#125;return baz;// badconst obj = &#123; foo() &#123;&#125;, bar() &#123;&#125;,&#125;;return obj;// goodconst obj = &#123; foo() &#123;&#125;, bar() &#123;&#125;,&#125;;return obj;// badconst arr = [function foo() &#123;&#125;, function bar() &#123;&#125;];return arr;// goodconst arr = [function foo() &#123;&#125;, function bar() &#123;&#125;];return arr; 19.8 不要用空白行填充块。eslint: padded-blocks 1234567891011121314151617181920212223// badfunction bar() &#123; console.log(foo);&#125;// also badif (baz) &#123; console.log(qux);&#125; else &#123; console.log(foo);&#125;// goodfunction bar() &#123; console.log(foo);&#125;// goodif (baz) &#123; console.log(qux);&#125; else &#123; console.log(foo);&#125; 19.9 不要在代码之间使用多个空白行填充。eslint: no-multiple-empty-lines 1234// badclass Person &#123; constructor(fullName, email, birthday) &#123; this.fullName = fullName; this.email = email; this.setAge(birthday); } setAge(birthday) { const today = new Date(); const age = this.getAge(today, birthday); this.age = age; } getAge(today, birthday) { // .. } } // good class Person { constructor(fullName, email, birthday) { this.fullName = fullName; this.email = email; this.setAge(birthday); } setAge(birthday) { const today = new Date(); const age = getAge(today, birthday); this.age = age; } getAge(today, birthday) { // .. } } 1 19.10 圆括号里不要加空格。eslint: space-in-parens 12345678910111213141516171819// badfunction bar(foo) &#123; return foo;&#125;// goodfunction bar(foo) &#123; return foo;&#125;// badif (foo) &#123; console.log(foo);&#125;// goodif (foo) &#123; console.log(foo);&#125; 19.11 方括号里不要加空格。 eslint: array-bracket-spacing 1234567// badconst foo = [1, 2, 3];console.log(foo[0]);// good，逗号分隔符后还是要空格的。const foo = [1, 2, 3];console.log(foo[0]); 19.12 花括号里加空格 。eslint: object-curly-spacing 12345// badconst foo = &#123; clark: &#x27;kent&#x27; &#125;;// goodconst foo = &#123; clark: &#x27;kent&#x27; &#125;; 19.13 避免一行代码超过 100 个字符（包含空格）。注意：对于 上面，长字符串不受此规则限制，不应换行。 eslint: max-len 为什么？这样确保可读性和可维护性。 12345678910111213141516171819202122232425262728293031// badconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy;// bad$.ajax(&#123; method: &#x27;POST&#x27;, url: &#x27;https://airbnb.com/&#x27;, data: &#123; name: &#x27;John&#x27; &#125; &#125;) .done(() =&gt; console.log(&#x27;Congratulations!&#x27;)) .fail(() =&gt; console.log(&#x27;You have failed this city.&#x27;));// goodconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy;// good$.ajax(&#123; method: &#x27;POST&#x27;, url: &#x27;https://airbnb.com/&#x27;, data: &#123; name: &#x27;John&#x27; &#125;,&#125;) .done(() =&gt; console.log(&#x27;Congratulations!&#x27;)) .fail(() =&gt; console.log(&#x27;You have failed this city.&#x27;)); 19.14 作为语句的花括号内也要加空格 —— &#123; 后和 &#125; 前都需要空格。 eslint: block-spacing 123456789101112131415// badfunction foo() &#123; return true;&#125;if (foo) &#123; bar = 0;&#125;// goodfunction foo() &#123; return true;&#125;if (foo) &#123; bar = 0;&#125; 19.15 , 前不要空格， , 后需要空格。 eslint: comma-spacing 123456789// badvar foo = 1, bar = 2;var arr = [1, 2];// goodvar foo = 1, bar = 2;var arr = [1, 2]; 19.16 花括号跟属性间要有空格，中括号跟属性间没有空格。 eslint: computed-property-spacing 译者注：以代码为准。 1234567891011// badobj[foo];obj[&#x27;foo&#x27;];var x = &#123; [b]: a &#125;;obj[foo[bar]];// goodobj[foo];obj[&#x27;foo&#x27;];var x = &#123; [b]: a &#125;;obj[foo[bar]]; 19.17 调用函数时，函数名和小括号之间不要空格。 eslint: func-call-spacing 1234567// badfunc();func();// goodfunc(); 19.18 在对象的字面量属性中， key 和 value 之间要有空格。 eslint: key-spacing 123456// badvar obj = &#123; foo: 42 &#125;;var obj2 = &#123; foo: 42 &#125;;// goodvar obj = &#123; foo: 42 &#125;; 19.19 行末不要空格。 eslint: no-trailing-spaces 19.20 避免出现多个空行。 在文件末尾只允许空一行。文件开始处不要出现空行。eslint: no-multiple-empty-lines 12// bad - multiple empty linesvar x = 1; var y = 2; // bad - 2+ newlines at end of filevar x = 1;var y = 2; // bad - 1+ newline(s) at beginning of file var x = 1;var y = 2; // goodvar x = 1;var y = 2; 1&lt;!-- markdownlint-enable MD012 --&gt; ⬆ 返回顶部 逗号 20.1 不要前置逗号。eslint: comma-style 123456789101112131415161718192021// badconst story = [once, upon, aTime];// goodconst story = [once, upon, aTime];// badconst hero = &#123; firstName: &#x27;Ada&#x27;, lastName: &#x27;Lovelace&#x27;, birthYear: 1815, superPower: &#x27;computers&#x27;,&#125;;// goodconst hero = &#123; firstName: &#x27;Ada&#x27;, lastName: &#x27;Lovelace&#x27;, birthYear: 1815, superPower: &#x27;computers&#x27;,&#125;; 20.2 额外结尾逗号: 要 eslint: comma-dangle 为什么？这使 git diffs 更简洁。此外，像 Babel 这样的转换器会删除转换代码中的额外的逗号，这意味着你不必担心旧版浏览器中的 结尾逗号问题。 1234567891011121314// bad - 没有结尾逗号的 git diffconst hero = &#123; firstName: &#x27;Florence&#x27;,- lastName: &#x27;Nightingale&#x27;+ lastName: &#x27;Nightingale&#x27;,+ inventorOf: [&#x27;coxcomb chart&#x27;, &#x27;modern nursing&#x27;]&#125;;// good - 有结尾逗号的 git diffconst hero = &#123; firstName: &#x27;Florence&#x27;, lastName: &#x27;Nightingale&#x27;,+ inventorOf: [&#x27;coxcomb chart&#x27;, &#x27;modern nursing&#x27;],&#125;; 123456789101112131415161718192021222324252627282930313233343536373839// badconst hero = &#123; firstName: &#x27;Dana&#x27;, lastName: &#x27;Scully&#x27;,&#125;;const heroes = [&#x27;Batman&#x27;, &#x27;Superman&#x27;];// goodconst hero = &#123; firstName: &#x27;Dana&#x27;, lastName: &#x27;Scully&#x27;,&#125;;const heroes = [&#x27;Batman&#x27;, &#x27;Superman&#x27;];// badfunction createHero(firstName, lastName, inventorOf) &#123; // does nothing&#125;// goodfunction createHero(firstName, lastName, inventorOf) &#123; // does nothing&#125;// good (注意，逗号不应出现在使用了 ... 操作符后的参数后面)function createHero(firstName, lastName, inventorOf, ...heroArgs) &#123; // does nothing&#125;// badcreateHero(firstName, lastName, inventorOf);// goodcreateHero(firstName, lastName, inventorOf);// good (注意，逗号不应出现在使用了 ... 操作符后的参数后面)createHero(firstName, lastName, inventorOf, ...heroArgs); ⬆ 返回顶部 分号 21.1 要分号！ eslint: semi 为什么？当 JavaScript 遇到没有分号结尾的一行，它会执行 自动插入分号 这一规则来决定行末是否加分号。如果 JavaScript 在你的断行里错误的插入了分号，就会出现一些古怪的行为。当新的功能加到 JavaScript 里后， 这些规则会变得更复杂难懂。清晰的结束语句，并通过配置代码检查去检查没有带分号的地方可以帮助你防止这种错误。 123456789101112131415161718192021222324252627282930313233343536// bad - 抛出异常const luke = &#123;&#125;;const leia = &#123;&#125;[(luke, leia)].forEach(jedi =&gt; (jedi.father = &#x27;vader&#x27;));// bad - 抛出异常const reaction = &#x27;No! That’s impossible!&#x27;( (async function meanwhileOnTheFalcon() &#123; // 处理 `leia`, `lando`, `chewie`, `r2`, `c3p0` // ... &#125;)());// bad - 将返回 `undefined` 而不是下一行的值。由于 ASI，当 `return`单独出现在一行时，这种情况会一直出现。function foo() &#123; return; (&#x27;search your feelings, you know it to be foo&#x27;);&#125;// goodconst luke = &#123;&#125;;const leia = &#123;&#125;;[luke, leia].forEach(jedi =&gt; &#123; jedi.father = &#x27;vader&#x27;;&#125;);// goodconst reaction = &#x27;No! That’s impossible!&#x27;;(async function meanwhileOnTheFalcon() &#123; // handle `leia`, `lando`, `chewie`, `r2`, `c3p0` // ...&#125;)();// goodfunction foo() &#123; return &#x27;search your feelings, you know it to be foo&#x27;;&#125; 更多. ⬆ 返回顶部 类型转换与强制转换 22.1 在语句开始执行强制类型转换。 22.2 字符串: eslint: no-new-wrappers 12345678910111213// =&gt; this.reviewScore = 9;// badconst totalScore = new String(this.reviewScore); // typeof totalScore is &quot;object&quot; not &quot;string&quot;// badconst totalScore = this.reviewScore + &#x27;&#x27;; // 将会执行 this.reviewScore.valueOf()// badconst totalScore = this.reviewScore.toString(); // 不保证返回 string// goodconst totalScore = String(this.reviewScore); 22.3 数字: 用 Number 做类型转换，parseInt 转换 string 应总是带上基数。 eslint: radix 为什么？函数 parseInt 会根据指定的基数将字符串转换为数字。字符串开头的空白字符将会被忽略，如果参数基数（第二个参数）为 undefined 或者 0 ，除非字符串开头为 0x 或 0X（十六进制），会默认假设为 10。这个差异来自 ECMAScript 3，它不鼓励（但是允许）解释八进制。在 2013 年之前，一些实现不兼容这种行为。因为我们需要支持旧浏览器，所以应当始终指定进制。 译者注：翻译的可能不是很好，总之使用 parseInt() 时始终指定进制数（第二个参数）就可以了。 12345678910111213141516171819const inputValue = &#x27;4&#x27;;// badconst val = new Number(inputValue);// badconst val = +inputValue;// badconst val = inputValue &gt;&gt; 0;// badconst val = parseInt(inputValue);// goodconst val = Number(inputValue);// goodconst val = parseInt(inputValue, 10); 22.4 请在注释中解释为什么要用移位运算和你在做什么。无论你做什么狂野的事，比如由于 parseInt 是你的性能瓶颈导致你一定要用移位运算。说明这个是因为 性能原因。 123456// good/** * parseInt 是代码运行慢的原因 * 用 Bitshifting 将字符串转成数字使代码运行效率大幅提升 */const val = inputValue &gt;&gt; 0; 22.5 注意: 用移位运算要小心。数字是用 64-位表示的，但移位运算常常返回的是 32 为整形source)。移位运算对大于 32 位的整数会导致意外行为。Discussion. 最大的 32 位整数是 2,147,483,647: 1232147483647 &gt;&gt; 0; //=&gt; 21474836472147483648 &gt;&gt; 0; //=&gt; -21474836482147483649 &gt;&gt; 0; //=&gt; -2147483647 22.6 布尔: eslint: no-new-wrappers 12345678910const age = 0;// badconst hasAge = new Boolean(age);// goodconst hasAge = Boolean(age);// bestconst hasAge = !!age; ⬆ 返回顶部 命名规范 23.1 避免用一个字母命名，让你的命名有意义。eslint: id-length 123456789// badfunction q() &#123; // ...&#125;// goodfunction query() &#123; // ...&#125; 23.2 用小驼峰命名法来命名你的对象、函数、实例。eslint: camelcase 12345678// badconst OBJEcttsssss = &#123;&#125;;const this_is_my_object = &#123;&#125;;function c() &#123;&#125;// goodconst thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125; 23.3 用大驼峰命名法来命名类。eslint: new-cap 12345678910111213141516171819// badfunction user(options) &#123; this.name = options.name;&#125;const bad = new user(&#123; name: &#x27;nope&#x27;,&#125;);// goodclass User &#123; constructor(options) &#123; this.name = options.name; &#125;&#125;const good = new User(&#123; name: &#x27;yup&#x27;,&#125;); 23.4 不要用前置或后置下划线。eslint: no-underscore-dangle 为什么？JavaScript 没有私有属性或私有方法的概念。尽管前置下划线通常的概念上意味着私有，事实上，这些属性是完全公有的，因此这部分也是你的 API 的内容。这一概念可能会导致开发者误以为更改这个不会导致崩溃或者不需要测试。如果你想要什么东西变成私有，那就不要让它在这里出现。 1234567// badthis.__firstName__ = &#x27;Panda&#x27;;this.firstName_ = &#x27;Panda&#x27;;this._firstName = &#x27;Panda&#x27;;// goodthis.firstName = &#x27;Panda&#x27;; 23.5 不要保存引用 this，用箭头函数或 函数绑定——Function#bind。 12345678910111213141516171819202122// badfunction foo() &#123; const self = this; return function () &#123; console.log(self); &#125;;&#125;// badfunction foo() &#123; const that = this; return function () &#123; console.log(that); &#125;;&#125;// goodfunction foo() &#123; return () =&gt; &#123; console.log(this); &#125;;&#125; 23.6 export default 导出模块 A，则这个文件名也叫 A.*， import 时候的参数也叫 A。 大小写完全一致。 123456789101112131415161718192021222324252627282930// file 1 contentsclass CheckBox &#123; // ...&#125;export default CheckBox;// file 2 contentsexport default function fortyTwo() &#123; return 42; &#125;// file 3 contentsexport default function insideDirectory() &#123;&#125;// in some other file// badimport CheckBox from &#x27;./checkBox&#x27;; // PascalCase import/export, camelCase filenameimport FortyTwo from &#x27;./FortyTwo&#x27;; // PascalCase import/filename, camelCase exportimport InsideDirectory from &#x27;./InsideDirectory&#x27;; // PascalCase import/filename, camelCase export// badimport CheckBox from &#x27;./check_box&#x27;; // PascalCase import/export, snake_case filenameimport forty_two from &#x27;./forty_two&#x27;; // snake_case import/filename, camelCase exportimport inside_directory from &#x27;./inside_directory&#x27;; // snake_case import, camelCase exportimport index from &#x27;./inside_directory/index&#x27;; // requiring the index file explicitlyimport insideDirectory from &#x27;./insideDirectory/index&#x27;; // requiring the index file explicitly// goodimport CheckBox from &#x27;./CheckBox&#x27;; // PascalCase export/import/filenameimport fortyTwo from &#x27;./fortyTwo&#x27;; // camelCase export/import/filenameimport insideDirectory from &#x27;./insideDirectory&#x27;; // camelCase export/import/directory name/implicit &quot;index&quot;// ^ supports both insideDirectory.js and insideDirectory/index.js 23.7 当你 export-default 一个函数时，函数名用小驼峰，文件名需要和函数名一致。 12345function makeStyleGuide() &#123; // ...&#125;export default makeStyleGuide; 23.8 当你 export 一个结构体/类/单例/函数库/对象 时用大驼峰。 12345const AirbnbStyleGuide = &#123; es6: &#123;&#125;,&#125;;export default AirbnbStyleGuide; 23.9 简称和缩写应该全部大写或全部小写。 为什么？名字都是给人读的，不是为了去适应计算机算法。 12345678910111213141516171819202122232425262728// badimport SmsContainer from &#x27;./containers/SmsContainer&#x27;;// badconst HttpRequests = [ // ...];// goodimport SMSContainer from &#x27;./containers/SMSContainer&#x27;;// goodconst HTTPRequests = [ // ...];// also goodconst httpRequests = [ // ...];// bestimport TextMessageContainer from &#x27;./containers/TextMessageContainer&#x27;;// bestconst requests = [ // ...]; 23.10 你可以用全大写字母设置静态变量，他需要满足三个条件。 导出变量； 是 const 定义的， 保证不能被改变； 这个变量是可信的，他的子属性都是不能被改变的。 为什么？这是一个附加工具，帮助开发者去辨识一个变量是不是不可变的。UPPERCASE_VARIABLES 能让开发者知道他能确信这个变量（以及他的属性）是不会变的。 对于所有的 const 变量呢？ —— 这个是不必要的。大写变量不应该在同一个文件里定义并使用， 它只能用来作为导出变量。 那导出的对象呢？ —— 大写变量处在 export 的最高级(例如：EXPORTED_OBJECT.key) 并且他包含的所有子属性都是不可变的。（译者注：即导出的变量是全大写的，但他的属性不用大写） 123456789// badconst PRIVATE_VARIABLE = &#x27;should not be unnecessarily uppercased within a file&#x27;;// badexport const THING_TO_BE_CHANGED = &#x27;should obviously not be uppercased&#x27;;// badexport let REASSIGNABLE_VARIABLE = &#x27;do not use let with uppercase variables&#x27;; // — // 允许但不够语义化export const apiKey = ‘SOMEKEY’; // 在大多数情况下更好export const API_KEY = ‘SOMEKEY’; // — // bad - 不必要的大写键，没有增加任何语义export const MAPPING = {KEY: ‘value’}; // goodexport const MAPPING = {key: ‘value’}; 1 ⬆ 返回顶部 Get-Set 访问器 24.1 不需要使用属性的访问器函数。 24.2 不要使用 JavaScript 的 getters/setters，因为他们会产生副作用，并且难以测试、维护和理解。相反的，你可以用 getVal() 和 setVal(&#39;hello&#39;) 去创造你自己的访问器函数。 123456789101112131415161718192021// badclass Dragon &#123; get age() &#123; // ... &#125; set age(value) &#123; // ... &#125;&#125;// goodclass Dragon &#123; getAge() &#123; // ... &#125; setAge(value) &#123; // ... &#125;&#125; 24.3 如果属性/方法是 boolean， 用 isVal() 或 hasVal()。 123456789// badif (!dragon.age()) &#123; return false;&#125;// goodif (!dragon.hasAge()) &#123; return false;&#125; 24.4 用 get() 和 set() 函数是可以的，但是要一起用。 1234567891011121314class Jedi &#123; constructor(options = &#123;&#125;) &#123; const lightsaber = options.lightsaber || &#x27;blue&#x27;; this.set(&#x27;lightsaber&#x27;, lightsaber); &#125; set(key, val) &#123; this[key] = val; &#125; get(key) &#123; return this[key]; &#125;&#125; ⬆ 返回顶部 事件 25.1 当传递数据载荷给事件时（不论是 DOM 还是像 Backbone 这样有很多属性的事件）。这使得后续的贡献者（程序员）向这个事件添加更多的数据时不用去找或者更新每个处理器。例如： 12345678// bad$(this).trigger(&#x27;listingUpdated&#x27;, listing.id);// ...$(this).on(&#x27;listingUpdated&#x27;, (e, listingID) =&gt; &#123; // do something with listingID&#125;); prefer: 12345678// good$(this).trigger(&#x27;listingUpdated&#x27;, &#123; listingID: listing.id &#125;);// ...$(this).on(&#x27;listingUpdated&#x27;, (e, data) =&gt; &#123; // do something with data.listingID&#125;); ⬆ 返回顶部 jQuery 26.1 jQuery 对象用$变量表示。 12345678// badconst sidebar = $(&#x27;.sidebar&#x27;);// goodconst $sidebar = $(&#x27;.sidebar&#x27;);// goodconst $sidebarBtn = $(&#x27;.sidebar-btn&#x27;); 26.2 缓存 jQuery 查找。 12345678910111213141516171819202122// badfunction setSidebar() &#123; $(&#x27;.sidebar&#x27;).hide(); // ... $(&#x27;.sidebar&#x27;).css(&#123; &#x27;background-color&#x27;: &#x27;pink&#x27;, &#125;);&#125;// goodfunction setSidebar() &#123; const $sidebar = $(&#x27;.sidebar&#x27;); $sidebar.hide(); // ... $sidebar.css(&#123; &#x27;background-color&#x27;: &#x27;pink&#x27;, &#125;);&#125; 26.3 DOM 查找用层叠式$(&#39;.sidebar ul&#39;) 或 父节点 &gt; 子节点 $(&#39;.sidebar &gt; ul&#39;). jsPerf 26.4 用 jQuery 对象查询作用域的 find 方法查询。 1234567891011121314// bad$(&#x27;ul&#x27;, &#x27;.sidebar&#x27;).hide();// bad$(&#x27;.sidebar&#x27;).find(&#x27;ul&#x27;).hide();// good$(&#x27;.sidebar ul&#x27;).hide();// good$(&#x27;.sidebar &gt; ul&#x27;).hide();// good$sidebar.find(&#x27;ul&#x27;).hide(); ⬆ back to top ECMAScript 5 兼容性 27.1 参考 Kangax 的 ES5 兼容性列表. ⬆ 返回顶部 ECMAScript 6+ (ES 2015+) 风格 28.1 这是收集到的各种 ES6 特性的链接 箭头函数——Arrow Functions 类——Classes 对象缩写——Object Shorthand 对象简写——Object Concise 对象计算属性——Object Computed Properties 模板字符串——Template Strings 解构赋值——Destructuring 默认参数——Default Parameters 剩余参数——Rest 数组拓展——Array Spreads Let and Const 幂操作符——Exponentiation Operator 迭代器和生成器——Iterators and Generators 模块——Modules 28.2 不要用 TC39 proposals， TC39 还没有到 stage 3。 为什么？ 它还不是最终版, 他可能还有很多变化，或者被撤销。我们想要用的是 JavaScript， 提议还不是 JavaScript。 ⬆ 回到顶部 标准库标准库中包含一些功能受损但是由于历史原因遗留的工具类 29.1 用 Number.isNaN 代替全局的 isNaN。eslint: no-restricted-globals 为什么？全局 isNaN 强制把非数字转成数字， 然后对于任何强转后为 NaN 的变量都返回 true如果你想用这个功能，就显式的用它。 1234567// badisNaN(&#x27;1.2&#x27;); // falseisNaN(&#x27;1.2.3&#x27;); // true// goodNumber.isNaN(&#x27;1.2.3&#x27;); // falseNumber.isNaN(Number(&#x27;1.2.3&#x27;)); // true 29.2 用 Number.isFinite 代替 isFinite.eslint: no-restricted-globals Why? 理由同上，会把一个非数字变量强转成数字，然后做判断。 123456// badisFinite(&#x27;2e3&#x27;); // true// goodNumber.isFinite(&#x27;2e3&#x27;); // falseNumber.isFinite(parseInt(&#x27;2e3&#x27;, 10)); // true 测试 30.1 Yup. 123function foo() &#123; return true;&#125; 30.2 No, but seriously: 无论用哪个测试框架，你都需要写测试。 尽量去写很多小而美的纯函数，减少突变的发生 小心 stub 和 mock —— 这会让你的测试变得脆弱。 在 Airbnb 首选 mocha。 tape 偶尔被用来测试一些小的、独立的模块。 100% 测试覆盖率是我们努力的目标，即便实际上很少达到。 每当你修了一个 bug， 都要写一个回归测试。 一个 bug 修复了，没有回归测试，很可能以后会再次出问题。 ⬆ 回到顶部 性能 On Layout &amp; Web Performance String vs Array Concat Try/Catch Cost In a Loop Bang Function jQuery Find vs Context, Selector innerHTML vs textContent for script text Long String Concatenation Are JavaScript functions like map(), reduce(), and filter() optimized for traversing arrays? Loading… ⬆ back to top };","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/tags/JavaScript/"},{"name":"指南","slug":"指南","permalink":"https://ly980408.github.io/tags/%E6%8C%87%E5%8D%97/"}]},{"title":"手把手教你用 Vite 搭建一个 Vue2 项目","slug":"手把手教你用-Vite-搭建一个-vue2-项目","date":"2022-05-01T14:00:00.000Z","updated":"2023-11-23T07:09:13.276Z","comments":true,"path":"posts/8c74c87a/","link":"","permalink":"https://ly980408.github.io/posts/8c74c87a/","excerpt":"","text":"前言Vite 是一种新型前端构建工具，能够显著提升前端开发体验。但在用它搭建项目时，选择vue模板，会默认创建一个 vue3 项目。那能不能用vite搭建一个vue2的项目呢？答案是可以的。我这里有一个已经搭建完的项目实例，具体方法请往下看。 搭建方法1. 创建一个 vite 项目以Yarn为例 先用 Vite 创建一个项目，详见官方文档 1$ yarn create vite 然后按提示操作！ 注意：在进行到第二步时时，即Select a framework:，不要选择vue，因为这样会创建一个vue3的项目，选择为vanilla，即原生 js, 然后通过插件和一些配置来改造成 vue2 项目。 2. 安装并配置依赖和插件安装 vue2 （此处我安装的为 2.6.14 版本） 及相关依赖： 1$ yarn add vue@2.6.14 vue-template-compiler 让 vite 支持 vue2，安装插件 vite-plugin-vue2： 1$ yarn add vite-plugin-vue2 -D 创建 vite.config.js 文件并引入插件： 1234567// vite.config.jsimport &#123; defineConfig &#125; from &#x27;vite&#x27;;import &#123; createVuePlugin as Vue2 &#125; from &#x27;vite-plugin-vue2&#x27;;export default defineConfig(&#123; plugins: [Vue2()],&#125;); 3. 修改目录和文件内容在根目录下创建 src 文件夹，并在文件夹下创建 App.vue： 1234&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt;Hello, Vue2 + Vite !&lt;/div&gt;&lt;/template&gt; 修改 main.js 文件内容并将其移入 src： 12345678// main.jsimport Vue from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;new Vue(&#123; el: &#x27;#app&#x27;, render: h =&gt; h(App),&#125;).$mount(); 关于 index.html，不需要创建public文件夹并将其移入（原因见：vite 官方文档），只需要修改 main.js 的路径即可： 12345&lt;!-- index.html --&gt;&lt;script type=&quot;module&quot; src=&quot;/main.js&quot;&gt;&lt;/script&gt;&lt;!-- 修改为 --&gt;&lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt; 至此，vite 搭建的 vue2 项目就基本完成了。运行项目： 1$ yarn dev 123456vite v2.9.6 dev server running at:&gt; Local: http:&#x2F;&#x2F;localhost:3000&#x2F;&gt; Network: use &#96;--host&#96; to exposeready in 520ms. 你可能会注意到，Network 那行好像不太对劲，我的 IP 地址打开方式哪去了？不要慌只需要去 vite.config.js 配置一下 server.host 就可以了。 123server: &#123; host: &#39;0.0.0.0&#39;&#125; 进阶设置详见 Github","categories":[],"tags":[{"name":"vite","slug":"vite","permalink":"https://ly980408.github.io/tags/vite/"},{"name":"vue","slug":"vue","permalink":"https://ly980408.github.io/tags/vue/"}],"author":"Yangyang"},{"title":"我把公司老旧Vue2项目由Webpack改为Vite后，开发体验直接起飞了","slug":"webpack-to-vite","date":"2022-03-17T14:18:00.000Z","updated":"2023-11-23T07:09:13.276Z","comments":true,"path":"posts/b8121b/","link":"","permalink":"https://ly980408.github.io/posts/b8121b/","excerpt":"","text":"Webpack to Vite1. 安装并配置 Vite1$ yarn add vite -D vite 默认没有对 vue2 的支持，我们需要先安装一个插件 vite-plugin-vue2 1$ yarn add vite-plugin-vue2 -D 然后在根目录下新建 vite.config.js 文件，添加内容： 1234567// vite.config.jsimport &#123; defineConfig &#125; from &#x27;vite&#x27;;import &#123; createVuePlugin as Vue2 &#125; from &#x27;vite-plugin-vue2&#x27;;export default defineConfig(&#123; plugins: [Vue2()],&#125;); 在package.json中加入脚本 1234567&#123; &quot;scripts&quot;: &#123; &quot;vite-dev&quot;: &quot;vite&quot;, &quot;vite-build&quot;: &quot;vite build&quot;, &quot;vite-preview&quot;: &quot;vite preview&quot; &#125;&#125; 将 index.html 移动（or 复制）到根目录下，记得修改文件路径 &lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt; 1$ yarn vite-dev 先把项目跑起来再说！ 2.问题及解决方案解决引入时省略文件扩展名问题(.vue/.js)例如： 123import tsc from &#x27;tsc.vue&#x27;;// 上面的写法可以，但是下面的会报错import tsc from &#x27;tsc&#x27;; 可以通过以下设置来解决（并不建议这么做）： 123456// vite.config.js&#123; resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;]; &#125;&#125; 但这其实并不是什么 bug，而是Vite有意这样设计的，详见issue，说不定啥时候就不支持这样配置了。所以最好还是老老实实把扩展名写全了吧。 设置别名 alias12345678// vite.config.js&#123; resolve: &#123; alias: &#123; &#x27;@&#x27;: path.resolve(__dirname, &#x27;src&#x27;) &#125; &#125;&#125; 包含多个别名的导入，如：@import &#39;~@/styles/global.scss&#39;，同时包含了别名~ 和@，您可以添加别名配置 &#123; find: /^~@/, replacement: path.resolve(__dirname, &#39;src&#39;) &#125; 到 resolve.alias 配置中，并且把该项配置移到别名配置中的第一项。 参考: https://github.com/originjs/webpack-to-vite/blob/main/README-zh.md xx is not defined.项目中使用的环境变量报错 process is not defined.vite.config.js 中添加： 1234567&#123; define: &#123; &#x27;process.env&#x27;: &#123; // ... &#125; &#125;&#125; 报错 require is not defined.，安装插件 @originjs/vite-plugin-commonjs，如果还需要对 require.context 支持，安装插件 @originjs/vite-plugin-require-context 123456// vite.config.jsimport &#123; viteCommonjs &#125; from &#x27;@originjs/vite-plugin-commonjs&#x27;;import ViteRequireContext from &#x27;@originjs/vite-plugin-require-context&#x27;;export default &#123; plugins: [viteCommonjs(), ViteRequireContext()],&#125;; 至此，白屏了半天的项目，终于出现画面了。当然，不要高兴的太早，看控制台还是一片红，还有很多未知的问题等着去解决呢。 require 动态引入图片如果你在模版中使用了 require 动态引入图片，例如 &lt;img :src=&quot;require(&#39;../assets/&#39; + imgName)&quot; /&gt;, 或许你又要看到 require is not defined. 的报错了，所以还需要继续改造我们的代码， 因为之前已经安装过插件去支持require，并且我还打算跟Webpack进行兼容（开发环境用Vite，生产环境继续用Webpack），所以在项目中采用了以下方法： 123456789101112// 关于 require.context() 的使用可自行查阅资料const images = require.context(&#x27;@/assets/images&#x27;);const getImageUrl = key =&gt; &#123; // key -&gt; &#x27;./image-name.png&#x27; if (!images.keys().includes(key)) &#123; return; &#125; return images(key);&#125;;// usage in template:// &lt;img :src=&quot;getImageUrl(&#x27;./my-image.png&#x27;)&quot; /&gt;// 可以在局部使用，也可以封装为全局方法 或者使用import.mate.url 3. 关于 build做了一些兼容性调整，生产环境构建继续采用 webpack","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://ly980408.github.io/tags/webpack/"},{"name":"vite","slug":"vite","permalink":"https://ly980408.github.io/tags/vite/"}],"author":"Yangyang"},{"title":"用 Vue 写一个Wordle游戏","slug":"用-vue-写一个Wordle游戏","date":"2022-02-12T14:49:00.000Z","updated":"2023-11-23T07:09:13.276Z","comments":true,"path":"posts/e91772b9/","link":"","permalink":"https://ly980408.github.io/posts/e91772b9/","excerpt":"","text":"一个很有意思的猜单词游戏，试玩一下。🎈 代码在这里 玩法介绍 共有六次机会来猜一个单词。 每个猜测必须是一个有效的五个字母的单词。点击 Enter 按钮提交。 每次猜测后，瓷砖的颜色都会改变，以显示您的猜测与单词的接近程度。 关于分享 如果朋友还没有猜过今天的随机单词的话，截图分享之前记得点击左上角的“隐藏答案”哦，防止剧透！ 自定义单词：在分享功能中，允许你自定义出题来分享给你的朋友猜测，再也不怕一个单词不过瘾了！ 参考Wordle 游戏的 Vue2 实现。 看到尤雨溪大佬的搞了一个 vue3 的项目，感觉挺有意思的就自己也搞一个 vue2 版本的。 仅供学习和娱乐。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://ly980408.github.io/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://ly980408.github.io/tags/vue/"},{"name":"wordle","slug":"wordle","permalink":"https://ly980408.github.io/tags/wordle/"},{"name":"game","slug":"game","permalink":"https://ly980408.github.io/tags/game/"}],"author":"Yangyang"},{"title":"「Leetcode」525 - 连续数组","slug":"leetcode-525","date":"2022-01-31T07:00:00.000Z","updated":"2023-11-23T07:09:13.276Z","comments":true,"path":"posts/e67f21f0/","link":"","permalink":"https://ly980408.github.io/posts/e67f21f0/","excerpt":"","text":"题目描述给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。 示例 1: 123​输入: nums &#x3D; [0,1] 输出: 2 说明: [0, 1] 是具有相同数量0和1的最长连续子数组。 示例 2: 123​输入: nums &#x3D; [0,1,0] 输出: 2 说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。 解题思路把 0 当作 -1，原题即变为求和为 0 的最长连续子数组。 代码实现123456789101112131415161718192021222324/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var findMaxLength = function (nums) &#123; let l = 0; let sum = 0; const map = new Map(); map.set(sum, -1); const n = nums.length; for (let i = 0; i &lt; n; i++) &#123; nums[i] ? sum++ : sum--; if (map.has(sum)) &#123; const lastIndex = map.get(sum); l = Math.max(l, i - lastIndex); &#125; else &#123; map.set(sum, i); &#125; &#125; return l;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://ly980408.github.io/categories/Leetcode/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://ly980408.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://ly980408.github.io/tags/leetcode/"}]},{"title":"JS数据类型的判断","slug":"js-getType","date":"2021-12-03T15:00:00.000Z","updated":"2023-11-23T07:09:13.276Z","comments":true,"path":"posts/c4f64af7/","link":"","permalink":"https://ly980408.github.io/posts/c4f64af7/","excerpt":"","text":"1234567891011121314function getType(target) &#123; return Object.prototype.toString.call(target).slice(8, -1);&#125;getType(123); // NumbergetType(&#x27;string&#x27;); // StringgetType(true); // BooleangetType(undefined); // UndefinedgetType(null); // NullgetType(&#123;&#125;); // ObjectgetType([]); // ArraygetType(function () &#123;&#125;); // FunctiongetType(/123/); // RegexpgetType(new Date()); // Date","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/tags/JavaScript/"}]},{"title":"ES6 知识梳理","slug":"ES6-知识梳理","date":"2021-07-20T06:30:08.000Z","updated":"2023-11-23T07:09:13.273Z","comments":true,"path":"posts/fbce3249/","link":"","permalink":"https://ly980408.github.io/posts/fbce3249/","excerpt":"","text":"ES6 —— 从一脸懵逼到灵活运用本文为笔者学习 ES6 时自用的知识梳理笔记，如有错误，欢迎指出～ var let constvar let const 的比较声明与赋值 var声明的变量是可以重新赋值的，也可以重复声明 let和const声明的变量都是不可以重复声明的 ​ 在不同作用域内可以出现同名变量，但并不相同，只能在各自的作用域中使用 不同的是， let声明的变量是可以重新赋值的，但 const不行 ​ 注意：用const声明的变量并不是完全不可以改变的 ​ 如果用const来声明一个对象，虽然无法给这个对象重新赋值，但是我们可以改变对象的属性值（对象是引 用类型变量，只改变对象的属性并不会影响指针指向） ​ 如果你也不希望改变属性值的话可以使用Object.freeze()方法 变量作用域 var 为 function scope 即函数作用域 在函数中声明的变量只能在函数中使用 如果在在if和for等语句里定义的变量你只希望在内部使用，var就无法满足，因为它没有在函数里声明，所以会变成一个全局变量，污染全局作用域 let 和 const 是 block scope 即块级作用域 一对大括号 { } 所包裹的内容即为一个块级作用域，声明的变量只能在块内使用，在块级作用域外调用则会报错 let 和 const 的使用场景 用let和const代替 IIFE IIFE 即 立即执行函数 ，应用之一就用来生成一个私有变量 1234567891011121314// 例如我们在window对象中有一个name属性，如果直接这样声明一个name变量的话会覆盖属性name的值// var name = &#x27;Tom&#x27;;// 我们通常会用一个立即执行函数来使变量私有化(function () &#123; var name = &#x27;Tom&#x27;; // do something&#125;)();// 如果使用 let 或者 const 就可以简单实现，只需要用一对大括号包裹起来，就形成了一个块级作用域&#123; let name = &#x27;Tom&#x27;; // do something&#125; for 循环 1234567891011121314for (var i = 0; i &lt; 10; i++) &#123; console.log(i); // 输出：0 1 2 3 ... 9 // 我们这里用setTimeout来模拟异步请求 setTimeout(function() &#123; console.log(&#x27;i:&#x27; + i); // 这里输出了10个 i:10 // 因为函数是延迟一秒执行的 此时 for 循环已经结束 &#125;, 1000)&#125;// 将 var 改成 let 即可得到想要的结果// 注意：不能使用 const ！ … 临时性死区 Temporal Dead Zone变量提升是指 JavaScript 将变量的声明移至作用域的顶部 12345678910console.log(color); // 不会报错 而是输出 undefinedvar color = &#x27;yellow&#x27;;// 因为有了变量提升实际上这段代码是这样的var color;console.log(color); // 所以这里会输出 undefinedcolor = &#x27;yellow&#x27;;// 如果将 var 换成 let 则会报 ReferenceError 在 ES6 中， let 也会将变量提升到块级作用域顶部，但你想在块级作用域中变量的声明之前引用的话就会报 ReferenceError， 因为它是在临时性死区中的， const 亦是如此需要注意的是，因为 const 定义的是一个常量，所以声明的同时必须赋初始值，否则会报错 使用建议 默认使用 const 当变量需要重新赋值时使用 let 尽量不使用 var Arrow Function 箭头函数优点： 简明的语法 可以隐式返回 不绑定this 简明的语法例如我们要用 map 遍历一个数组使其中的数乘以二返回 1234567891011121314const nums = [1, 3, 0, 5];const double = nums.map(function (num) &#123; return num * 2;&#125;);console.log(double); // [2, 6, 0, 10]// 改用箭头函数const double2 = nums.map((num) =&gt; &#123; return num * 2;&#125;);console.log(double2); // [2, 6, 0, 10] 箭头函数写法：去掉function关键字，加上 =&gt; 如果箭头函数只有一个参数的话，()可以省略，没有参数或者有多个参数则必须使用括号并且参数之间用,隔开 隐式返回显式返回即return关键字加上返回的内容。 箭头函数中的隐式返回： ​ 去掉return关键字 ， 去掉 &#123;&#125; ， 将表达式写到一行中 用于我们只想简单返回一些内容时使用，使代码更加简洁 12// like thisconst double3 = nums.map((num) =&gt; num * 2); 注： 因为箭头函数都是匿名函数，匿名函数在递归或者作为回调函数等场景时非常好用，但如果你只想作为一个简单函数的话我们一般把它赋值给一个变量来使用 this 问题在使用箭头函数以前我们经常遇到这样的问题 1234567891011121314151617const Tom = &#123; name: &#x27;Tom&#x27;, hobbies: [&#x27;Coding&#x27;, &#x27;Sleeping&#x27;, &#x27;Reading&#x27;], showHobbies: function () &#123; this.hobbies.forEach(function (hobby) &#123; console.log(this.name + &#x27; likes &#x27; + hobby); &#125;) &#125;&#125;Tom.showHobbies();/* 输出： likes Coding likes Coding likes Reading 咦，你会发现 Tom 不见了，看来是 this.name 的 this 指向出了问题*/ 这里的showHobbies()是由 对象Tom调用的，所以this指向的是对象Tom，因此 this.hobbies 可以正常取到； 而forEach()方法里的回调函数他不是作为对象的方法调用，也没有使用apply、call等方法来改变this指向，所以这里的this指向的是 Window 或者说全局（严格模式下为 undefined） 以前我们通常的做法是在这之前var self = this;，然后用self代替this来使用 在 ES6 中我们可以借助箭头函数来代替这种 hack 写法，因为箭头函数没有自己的this，它的this值是继承它的父级作用域的（词法作用域，由上下文确定） 箭头函数不适用的场景 作为构造函数，向原型对象中添加方法 当你真的需要this的时候，例如事件绑定 需要使用arguments对象时 参数默认值1234567891011// 直接定义在函数的形参后面function multiply (a, b = 1) &#123; return a * b;&#125;multiply(); // NaNmultiply(3); // 3multiply(3, 5); // 15// 传入 null 并不会使用默认值multiply(5, null); // 0 模板字符串在过去我们要组合 变量 和 字符串 的时候需要不停地用+进行连接，这样既繁琐又容易出错而且不易检查。 有了 ES6 的模板字符串就变得容易多了 模板字符串 允许我们用一对反引号 ` 来定义字符串 $&#123;&#125; 里面可以是任意的 JS 表达式，包括对象的属性，甚至是一个函数 123456const name = &#x27;Tom&#x27;;const age = 5;const text = `$&#123;name&#125; is $&#123;age * 5&#125; years old.`;console.log(text); // &quot;Tom is 25 years old.&quot; New String Methods12345678910111213141516171819202122232425262728const id = &#x27;adcd123456x&#x27;;const fan = &#x27;I love ES6.&#x27;// .startsWith()// 检查字符串是否以xx开头，返回布尔值，第二个参数传入开始位置索引，不传默认为0，大小写敏感id.startsWith(&#x27;abc&#x27;); // trueid.startsWith(&#x27;123&#x27;, 5);// truefan.startsWith(&#x27;I&#x27;); // truefan.startsWith(&#x27;i&#x27;); // false// .endsWith()// 检查字符串是否以xx结尾，返回布尔值，第二个参数传入结尾位置索引，不传默认为最后，大小写敏感id.endsWith(&#x27;x&#x27;); // trueid.endsWith(&#x27;X&#x27;); // falsefan.endsWith(&#x27;love&#x27;, 6); // true// .includes()// 检查子字符串是否包含于字符串中，返回布尔值，可以传入第二个参数，指定匹配开始位置索引，大小写敏感fan.indexOf(&#x27;ES6&#x27;) !== -1; // truefan.includes(&#x27;ES6&#x27;); // true// .repeat()// 将字符串重复n次，参数为重复次数( &gt;=0 ) 解构对象解构12345678910111213141516171819202122232425262728293031323334353637const Tom = &#123; name: &#x27;Tom Jones&#x27;, age: 25, family: &#123; mother: &#x27;Norah Jones&#x27;, father: &#x27;Richard Jones&#x27;, brother: &#x27;Howard Jones&#x27; &#125;&#125;// 1. without destructuring// const name = Tom.name;// const age = Tom.age;// ...// 2. with destructuring// 这行语句的意思：先声明变量 name 和 age ，然后在 Tom 对象中寻找同名属性，找到把属性值后赋值给变量const &#123; name, age &#125; = Tom;console.log(name); // &#x27;Tom Jones&#x27;console.log(age); // 25// 如果你想要赋值给已经声明的变量 将语句用()包裹起来// 因为如果不加 () 的话，解析器会把 &#123; &#125; 内的内容解析成一个代码块，而不是解构语法// let name = &#x27;&#x27;;// (&#123; name, age &#125; = Tom);// 对象解构中还允许对变量进行重命名// 比如 father 变量名已经被提前占用，下面语法中把 father 重新命名成了 dad// 如果我们去获取一个对象没有的属性时，则会返回 undefined// 当然也允许我们传入一个默认值，但只有在当对象该属性的值为 undefined 时才会使用默认值，null false 等不行const father = &quot;Tom&#x27;s Dad&quot;;const &#123; father: dad, son, sister = &#x27;no sister&#x27; &#125; = Tom.family;console.log(dad); // &#x27;Richard Jones&#x27;console.log(son); // undefinedconsole.log(sister); // &#x27;no sister&#x27; 数组解构1234567891011121314151617181920const numbers = [1, 2, 3, 4, 5]// 获取相对应位置的值const [one, two] = numbersconsole.log(one, two) // 1 2// 像这样用逗号隔开可以跳过某个索引位置const [yi, , san] = numbersconsole.log(yi, san) // 1 3// 如果变量数量多余数组的值的话 多余的会被赋值 undefined ，// 同样，我们也可以提供默认值， 当值为绝对的(===) undefined 时会使用默认值// 还有一种写法 ...others 会将剩余的内容保存到一个数组里const [first, ...others] = numbersconsole.log(first, others) // 1 [2, 3, 4, 5]// ... + 变量名 是 rest参数 ， 后面我们再介绍// 注意它只能出现在数组的最后面，否则会报错 以前我们要交换两个变量的值的时候，经常会定义一个中间变量，有了解构赋值我们就可以方便的进行交换了 12345678910111213let a = 10let b = 20// 引入中间变量let temptemp = aa = bb = tempconsole.log(a, b) // 20 10// 解构赋值[a, b] = [b, a]console.log(a, b) // 10 20 for of 循环for of 是 ES6 新增的一种循环方式 123456789101112131415161718192021222324252627282930313233343536const fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;orange&#x27;, &#x27;mango&#x27;]// 我们在遍历一个数组的时候， 常常有这几种方法：// 1. for 循环 - 这种方式既繁琐可读性又差for (let i = 0; i &lt; fruits.length; i++) &#123; console.log(fruits[i])&#125;// 2. 数组的 forEach() 方法 - 简化了for循环，而且可以有新的变量名 fruit，但此方法无法中止或跳出循环fruits.forEach(fruit =&gt; &#123; console.log(fruit)&#125;)// 3. for in 循环 -for (let fruit in fruits) &#123; console.log(fruit) // 0 1 2 3 : for in 循环的值是属性名而不是属性值，所以在遍历数组是返回的是索引值&#125;for (let index in fruits) &#123; console.log(fruits[index]) // apple banana orange mango&#125;// 但是还有一个问题，for in 循环遍历的是对象上的所以可枚举属性， 即使你是加在原型对象上// 比如我们给 fruits 加一个属性，这时候再去遍历输出， 你会发现输出多了个 My favorit fruits// for in 更适合用来遍历对象，不适合用来遍历数组fruits.description = &#x27;My favorit fruits&#x27;for (let index in fruits) &#123; console.log(fruits[index]) // apple banana orange mango My favorit fruits&#125;// 为了解决以上几种方法的缺陷 ES6 引入了新的循环方法 for of// 它解决了 for in 遍历内容为属性名 和 会遍历数组的非数字属性 的问题// 而且相对 forEach() 方法而言，它还支持循环中止和跳过for (let fruit of fruits) &#123; console.log(fruit) // apple banana orange mango&#125; New Array Methods.from() &amp; .of()这两个方法并不是原型上的方法，需要通过 Array 对象来调用，即Array.from()和 Array.of() Array.from()用于把一个类数组或者可遍历对象转换为一个真正的数组， 同时它还支持传入回调函数作为第二个参数 ，来对转换成的数组每一项执行一定的方法进行处理 Array.of()主要解决Array()构造函数传入不同数量的参数时行为不一致的问题： ​ 当你传入一个参数(例如：2)时，它会返回长度为 2 的数组(undefined x 2)，当你传入多个参数(例如：1,2,3)，这时它又会返回由这些参数组成的数组 而Array.of()无论你传入多少个参数，它都会返回由这些参数组成的数组 其他方法.find() .findIndex() .some() .every() find()方法用于返回数组中满足条件（函数内判断）的第一个元素的值 当数组中的元素在符合条件时返回，之后的值不会再调用执行函数 如果没有符合条件的元素则返回 undefined 语法：array.find(function(element, index, arr)) 参数：测试函数 function(element, index, arr) ​ element - 当前元素 ​ index - 当前元素索引 ​ arr - 正在执行该方法的数组 123456// 例如我们想要从ages数组中得到年龄大于等于18的第一个元素const ages = [3, 10, 17, 20]const res = ages.find((age) =&gt; &#123; return age &gt;= 18&#125;)console.log(res) // 18 findIndex()方法与find()方法类似，唯一不同就是它返回的是满足条件的元素的索引值 some()和every()用法类似，只不过返回的是一个布尔值 ​ 前者表示至少有一个满足，即找到一个满足条件的元素时返回true ​ 后者表示每一个都满足，即当所有元素都满足条件时才会返回true，当找到一个不满足条件的元素时就会立即返回false 剩余参数剩余参数语法允许我们将一个不定数量的参数表示为一个数组 当我们定义一个函数的时候，如果在最后一个参数前面加...前缀，就会将剩余参数存到一个数组中 语法： 123function(a, b, ...theArgs) &#123; // ...&#125; 12345678910// 比如我们定义一个函数来计算商品的折后价// 第一个参数传入的是折扣 后面的参数为商品原价// 这里我们就可以用到剩余参数啦，将价格存到一个数组中去function discount(rate, ...prcies) &#123; // 因为prices是一个数组，所以我们可以直接调用 map 方法 return prices.map((price) =&gt; price * rate)&#125;const discountPrices = discount(0.8, 100, 150, 1000)console.log(discountPrices) // [80, 120, 800] 前面我们提到过，剩余参数还以用于变量的解构 1234// 我们定义一个变量来记录玩家的 name id 和 scores// 利用剩余参数我们就可以方便的将分数都保存到一个数组里面const player = [&#x27;Tom&#x27;, 123456, 5.6, 7.3, 3,4, 8.9]const [name, id, ...scores] = player 扩展运算符（…）扩展运算符用法与剩余参数相反，它用于把可遍历对象的元素扩展为一个新的参数序列 1234// 把一个字符串中的每一个字符存到一个数组中const name = &#x27;Iverson&#x27;const arr = [...name]console.log(arr) // [&quot;I&quot;, &quot;v&quot;, &quot;e&quot;, &quot;r&quot;, &quot;s&quot;, &quot;o&quot;, &quot;n&quot;] 1234567// 把两个数组进行拼接可以用 concat 方法，但如果我们还要在两个数组的元素中间加入一个元素，就不太方便了// 这时候扩展运算符就出来拯救我们了const youngers = [&#x27;George&#x27;, &#x27;John&#x27;, &#x27;Thomas&#x27;]const olders = [&#x27;James&#x27;, &#x27;Adrew&#x27;, &#x27;Martin&#x27;]const members = [...youngers, &#x27;Mary&#x27;, ...olders]console.log(members) // [&quot;George&quot;, &quot;John&quot;, &quot;Thomas&quot;, &quot;Mary&quot;, &quot;James&quot;, &quot;Adrew&quot;, &quot;Martin&quot;] 对象字面量的扩展当我们在声明一个对象的时候，如果属性名和属性值所指向的变量名一致，可以简化书写 12345678910111213141516const name = &#x27;Tom&#x27;const age = 20const gender = &#x27;男&#x27;const Tom = &#123; name, // =&gt; name: name, age, // =&gt; age: age, gender // =&gt; gender: gender // 对象的方法也同样可以简写 /* getAge: function () &#123; alert(`I&#x27;m $&#123;this.name&#125;`) &#125; */ getAge () &#123; alert(`I&#x27;m $&#123;this.name&#125;`) &#125;&#125; ES6 还提供了计算属性，你可以在对象的属性名和属性值处写入 js 语句 12345678910const keys = [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;gender&#x27;]const values = [&#x27;Tom&#x27;, 20, &#x27;男&#x27;]const Tom = &#123; [keys.shift()]: values.shift(), [keys.shift()]: values.shift(), [keys.shift()]: values.shift()&#125;console.log(Tom) // &#123;name: &quot;Tom&quot;, age: 20, gender: &quot;男&quot;&#125; Promise以下内容来自于 MDN Web 文档， 查看更多 因为大部分情况下我们只是使用已创建的 Promise 实例对象，所以此处只简单介绍用法，要想了解 Promise 构造函数，点击此处 Promise 是一个对象，它代表了一个异步操作的最终完成或者失败。 本质上，Promise 是一个被某些函数传出的对象，我们附加回调函数（callback）使用它，而不是将回调函数传入那些函数内部。 约定 不同于“老式”的传入回调，在使用 Promise 时，会有以下约定： 在 本轮 Javascript event loop（事件循环）运行完成 之前，回调函数是不会被调用的。 通过 then() 添加的回调函数总会被调用，即便它是在异步操作完成之后才被添加的函数。 通过多次调用 then()，可以添加多个回调函数，它们会按照插入顺序一个接一个独立执行。 因此，Promise 最直接的好处就是链式调用（chaining）。 链式调用在过去，要想做多重的异步操作，会导致经典的回调地狱： 1234567doSomething(function(result) &#123; doSomethingElse(result, function(newResult) &#123; doThirdThing(newResult, function(finalResult) &#123; console.log(&#x27;Got the final result: &#x27; + finalResult); &#125;, failureCallback); &#125;, failureCallback);&#125;, failureCallback); 通过新的功能方法，我们把回调绑定到被返回的 Promise 上代替以往的做法，形成一个 Promise 链： 12345678910doSomething().then(function(result) &#123; return doSomethingElse(result);&#125;).then(function(newResult) &#123; return doThirdThing(newResult);&#125;).then(function(finalResult) &#123; console.log(&#x27;Got the final result: &#x27; + finalResult);&#125;).catch(failureCallback); then 里的参数是可选的，catch(failureCallback) 是 then(null, failureCallback) 的缩略形式。如下所示，我们也可以用箭头函数来表示： 1234567doSomething().then(result =&gt; doSomethingElse(result)).then(newResult =&gt; doThirdThing(newResult)).then(finalResult =&gt; &#123; console.log(`Got the final result: $&#123;finalResult&#125;`);&#125;).catch(failureCallback); Symbol symbol 是 ES6 新加的一种基本数据类型。 Symbol()函数会返回symbol类型的值，但它并不是构造函数，因为它不支持语法：new Symbol()。 每个从Symbol()返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符，这是该数据类型仅有的目的。 语法： Symbol([description]) description 为可选参数，字符串类型，是对 symbol 的描述 123const sym1 = Symbol()const sym2 = Symbol(&#x27;foo&#x27;)const sym3 = Symbol(&#x27;foo&#x27;) 上面的代码创建了三个新的 symbol 类型。 它们每一个都会是新的 symbol 类型，即使用了同样的描述： 1Symbol(&quot;foo&quot;) === Symbol(&quot;foo&quot;) // false 使用 new 运算符的语法将抛出 TypeError 错误： 1const sym = new Symbol() // TypeError Symbols 在 for...in 循环中不可枚举。另外，Object.getOwnPropertyNames() 也不会返回 symbol 类型的属性，但是你能使用 Object.getOwnPropertySymbols() 得到它们 Modules (模块)导出模块 export 命名导出 named exports 为了获得模块的功能要做的第一件事是把它们导出来。使用 export 语句来完成。 最简单的方法是把它（指 export 语句）放到你想要导出的项前面，比如： 12345export const name = &#x27;square&#x27;export function funcName() &#123; // ...&#125; 你能够导出函数，var，let，const, 和类。export 要放在最外层；比如你不能够在函数内使用export。 一个更方便的方法导出所有你想要导出的模块的方法是在模块文件的末尾使用一个 export 语句， 用花括号括起来你想导出的模块并用逗号分割。比如： export &#123; name, age, func1, func2 &#125; 此方式还支持你对导出的模块使用as进行重命名： export &#123; name as n, age as a, func1, func2 &#125; 这样在你导入的时候就需要使用as后的变量名进行导入 默认导出 default export 上面方法导出的功能都是由 named exports 组成 — 每个项目（无论是函数，常量等）在导出时都由其名称引用，并且该名称也用于在导入时引用它。 还有一种导出类型叫做 default export 语法：export default xxx ，xxx 为你要导出的项目的名字 ​ 我们还可以把 export default 放到函数或者类的前面： ​ export default function() &#123;&#125; ​ export default class &#123;&#125; 注意，不能使用 var、let 或 const 用于导出默认值 export default。 关于两种导出方式 你能够在每一个模块中定义多个命名导出，但是只允许有一个默认导出。在导出多个值时，命名导出非常有用。在导入期间，必须使用相应对象的相同名称。但是，你可以使用任何名称导入默认导出的模块。 导入模块 import语法： 12345import defaultExport from &quot;module-name&quot;import * as name from &quot;module-name&quot;import &#123; export &#125; from &quot;module-name&quot;import &#123; export as alias &#125; from &quot;module-name&quot;import &#123; export1 , export2 &#125; from &quot;module-name&quot; defaultExport 导入默认导出时的的引用名 module-name 要导入的模块。通常是包含目标模块的.JavaScript文件的相对或绝对路径名，可以不包括.JavaScript扩展名。 name 导入模块对象整体的别名 export, export1, export2 被导入模块的导出接口的名称 ( 命名导出，导入时需使用相同的名称 ) alias 用于引用指定导入的名称 ( 同导出时，导入时也可以使用 as 进行重命名 ) Class ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。 基本语法12345678910111213141516171819202122232425// 传统方法 通过构造函数定义并生成一个新的对象function Person (name, age) &#123; this.name = name this.age = age&#125;// 向原型对象中添加方法Person.prototype.sayName = function () &#123; console.log(`My name is $&#123;this.name&#125;`)&#125;// 创造实例const p1 = new Person(&#x27;Tom&#x27;, 21)// ===========================================// 定义类class Person &#123; constructor(x, y) &#123; this.x = x this.y = y &#125; sayName() &#123; console.log(`My name is $&#123;this.name&#125;`) &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5 的构造函数Person，对应 ES6 的Person类的构造方法。 Person类除了构造方法，还定义了一个sayName方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6 的类，完全可以看作构造函数的另一种写法。 123456class Person &#123; // ...&#125;typeof Person // &quot;function&quot;Person === Person.prototype.constructor // true 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。在类的实例上面调用方法，其实就是调用原型上的方法。 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。 12345678910class Person &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Person.prototype, &#123; sayName()&#123;&#125;, sayAge()&#123;&#125;&#125;) 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 支持计算属性：类的属性名，可以采用表达式。 1234567891011121314let methodName = &#x27;greet&#x27;class MyClass &#123; constructor()&#123; // ... &#125; [methodName] () &#123; console.log(&#x27;Hello&#x27;) &#125;&#125;const class1 = new MyClass()class1.greet() // &quot;Hello&quot; constructor 方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo// false 类的实例对象生成类的实例对象的写法，与 ES5 完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 12345678910111213141516171819202122//定义类class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; sayName() &#123; console.log(`My name is $&#123;this.name&#125;`) &#125;&#125;var person = new Person(&#x27;Tom&#x27;, 21);person.sayName() // My name is Tomperson.hasOwnProperty(&#x27;name&#x27;) // trueperson.hasOwnProperty(&#x27;age&#x27;) // trueperson.hasOwnProperty(&#x27;sayName&#x27;) // falseperson.__proto__.hasOwnProperty(&#x27;sayName&#x27;) // true 类的所有实例共享一个原型对象。 12345var p1 = new Person(&#x27;Tom&#x27;,21);var p2 = new Person(&#x27;Jerry&#x27;,20);p1.__proto__ === p2.__proto__//true 上面代码中，p1和p2都是 Point 的实例，它们的原型都是 Point.prototype，所以__proto__属性是相等的。 这也意味着，可以通过实例的__proto__属性为 Class 添加方法。 不存在变量提升Class 不存在变量提升（hoist），这一点与 ES5 完全不同。 Class 表达式与函数一样，类也可以使用表达式的形式定义。 12345const MyClass = class Me &#123; getClassName() &#123; return Me.name &#125;&#125; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。 123let inst = new MyClass()inst.getClassName() // MeMe.name // ReferenceError: Me is not defined 上面代码表示，Me只在 Class 内部有定义。 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 1const MyClass = class &#123; /* ... */ &#125; 采用 Class 表达式，可以写出立即执行的 Class。 1234567891011let person = new class &#123; constructor(name) &#123; this.name = name &#125; sayName() &#123; console.log(this.name) &#125;&#125;(&#x27;张三&#x27;)person.sayName() // &quot;张三&quot; 上面代码中，person是一个立即执行的类的实例。 静态方法静态方法就是直接定义在构造函数上的方法，例如 Array.from()和 Array.of()，只能通过构造函数 Array 来调用，而不能通过实例进行调用。 在 class 类中，我们通过static关键字来定义一个静态方法 1234567891011121314class MyClass() &#123; constructor() &#123; // ... &#125; static func()&#123; console.log(&#x27;I am a static method&#x27;) &#125;&#125;const class1 = new MyClass()MyClass.func() // &quot;I am a static method&quot;class1.func() // error getter 和 setter在 Class 内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return &#x27;getter&#x27; &#125; set prop(value) &#123; console.log(&#x27;setter: &#x27;+value) &#125;&#125;const inst = new MyClass()inst.prop = 123;// setter: 123inst.prop// &#x27;getter&#x27; class 的继承Class 之间可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 1class Cat extends Pet &#123;&#125; 上面代码定义了一个Cat类，该类通过extends关键字，继承了Pet类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Pet类。下面，我们在Cat内部加上代码。 123456789101112131415161718192021class Pet &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; greet() &#123; console.log(&#x27;Hello&#x27;) &#125;&#125;class Cat extends Pet &#123; constructor(name, age, food) &#123; super(name, age); this.food = &#x27;fish&#x27; &#125; greet() &#123; console.log(&#x27;Meow~&#x27;) &#125;&#125; 上面代码中，constructor方法中出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 子类Cat的greet方法覆盖了父类中的greet方法 迭代器和生成器 处理集合中的每个项是很常见的操作。JavaScript 提供了许多迭代集合的方法，从简单的 for循环到 map() 和 filter()。迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义 for...of 循环的行为。 Proxy Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。 语法 let p = new Proxy(target, handler); 参数: target 用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handler 一个对象，其属性是当执行一个操作时定义代理的行为的函数。 Reflect- SetES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set 本身是一个构造函数，用来生成 Set 数据结构。 语法new Set([iterable]); 参数 iterable 如果传递一个可迭代对象，它的所有元素将不重复地被添加到新的 Set 中。如果不指定此参数或其值为null，则新的 Set 为空。 返回值 一个新的Set对象。 值的相等向 Set 加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===）。NaN和undefined都可以被存储在 Set 中， NaN之间被视为相同的值（不同于精确相等）。 由于对象为引用数据类型，两个空对象不相等，所以它们被视为两个值。 属性和方法Set 的实例对象有以下属性： Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set 的实例对象的方法： add(value)：向尾部添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 key方法、value方法、entries方法返回的都是遍历器对象（详见Iterator对象）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以key方法和value方法的行为完全一致。 entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。 Set 的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。Set.prototype[Symbol.iterator] === Set.prototype.values这意味着，可以省略values方法，直接用for...of循环遍历 Set。 forEach方法，用于对每个成员执行某种操作，没有返回值。参数是一个处理函数，该函数的参数依次为 键值、键名、集合自身。另外，forEach方法还可以传入第二个参数，表示绑定的 this 对象。 扩展运算符 (...) 可用于 Set 结构，两者结合使用，可以用来去除数组重复成员： 123let arr = [3, 5, 2, 2, 5, 5]let unique = [...new Set(arr)]// [3, 5, 2] WeakSet语法1new WeakSet([iterable]); 参数 iterable 如果传入一个可迭代对象作为参数, 则该对象的所有迭代值都会被自动添加进生成的 WeakSet 对象中。null 被认为是 undefined。 描述WeakSet 对象是一些对象值的集合, 并且其中的每个对象值都只能出现一次。在WeakSet的集合中是唯一的 它和 Set 对象的区别有两点: 与Set相比，WeakSet 只能是对象的集合，而不能是任何类型的任意值。 WeakSet持弱引用：集合中对象的引用为弱引用。 如果没有其他的对WeakSet中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着 WeakSet 中没有存储当前对象的列表。 正因为这样，WeakSet 是不可枚举的。 方法 add(value) 在该 WeakSet 对象中添加一个新元素 value. delete(value) 从该 WeakSet 对象中删除 value这个元素, 之后 has(value) 方法便会返回 false. has(value) 返回一个布尔值, 表示给定的值 value 是否存在于这个 WeakSet 中. Map Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。 描述键的相等NaN 是与 NaN 相等的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。 与 Object 的比较Object 和 Map 类似的是，它们都是一种用来存储键值对的数据类型，因此我们过去一直把对象当成 Map 使用。但在有些场景情况下 Map 会是更好的选择： Map 默认不包含任何键，只能通过显式插入，而 Object 有一个原型，原型链上的键名有可能和你自己设置的键名产生冲突； Map 的键可以是任意值（包括对象、函数和基本类型），而 Object 的键只能是 String 或者 Symbol； Map 的键是有序的，而 Object 的键是无序的； Map 是 iterable 的，所以可以直接被迭代； … 方法 clear()移除 Map 对象的所有键/值对 。 delete(key)如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false。随后调用 has(key) 将返回 false 。 entries()返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。 forEach(callbackFn[, thisArg])按插入顺序，为 Map 对象里的每一键值对调用一次 callbackFn 函数。如果为 forEach 提供了 thisArg，它将在每次回调中作为 this 值。 get(key)返回键对应的值，如果不存在，则返回 undefined。 has(key)返回一个布尔值，表示 Map 实例是否包含键对应的值。 keys()返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键 。 set(key, value)设置 Map 对象中键的值。返回该 Map 对象。 values()返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值 。 参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScripthttps://es6.ruanyifeng.com/","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"https://ly980408.github.io/tags/JavaScirpt/"},{"name":"ES6","slug":"ES6","permalink":"https://ly980408.github.io/tags/ES6/"}]},{"title":"Hexo 文章永久链接（Permalink）","slug":"hexo-post-permalink","date":"2021-06-23T07:00:00.000Z","updated":"2023-11-23T07:09:13.276Z","comments":true,"path":"/posts/my_custom_permalink.html","link":"","permalink":"https://ly980408.github.io/posts/my_custom_permalink.html","excerpt":"","text":"本文主要是推荐使用 hexo-abbrlink 插件进行设置永久链接点击这里跳过废话，直接开搞 注意！！！经测试发现，permalink 必须添加 .html 后缀或者以 / 结尾，否则在你点击文章时，浏览器会由于错误识别类型默认进行下载，而非打开文章页面。 WhatHexo Docs - 永久链接（Permalinks）Hexo 在生成博客文章链接时，默认是按照年、月、日、标题格式来生成可以在 _config.yml 中的 permalink 设置，默认是 :year/:month/:day/:title _config.yml1permalink: :year/:month/:day/:title/ Why这样默认的设置会有以下几个缺点： 当我们把源文件名改掉之后，链接也会改变 如果文章标题很长，那么文章链接也会很长 如果文章名包含中文，转码后链接一串乱码，不美观 不利于SEO How指定 permalink我们可以在 Front-matter（即文件最上方以 --- 分隔的区域，用于指定个别文件的变量）中自定义每个文章的 permalink 12345678---title: 这是文章标题tags: 这是标签categories: 这是分类permalink: my_custom_permalink.html---content... 这样做会覆盖你在 _config.yml 中设置的 permalink文章链接会变为domain/my_custom_permalink.html但你需要为每篇文章都单独设置一个 permalink ，否则他还将是采用默认的设置 hexo-abbrlink 插件（推荐） 首先安装插件 1npm install hexo-abbrlink --save 修改配置文件 _config.yml _config.yml12345permalink: posts/:abbrlink.html # 也可以直接写成 /:abbrlink.html# abbrlink configabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 重新生成静态文件 12hexo cl &amp;&amp; hexo ghexo s 这样 Hexo 在生成静态文件时会按照你设定的规则给你的每一篇文章添加一个 abbrlink 属性用于生成永久链接 这样一来妈妈再也不用担心文章地址过长或者失效的问题了快去给你自己的博客搞起来吧！ Reference https://hexo.io/zh-cn/docs/permalinks https://github.com/rozbo/hexo-abbrlink https://zhuanlan.zhihu.com/p/169492685 https://blog.csdn.net/yanzi1225627/article/details/77761488","categories":[{"name":"关于博客","slug":"关于博客","permalink":"https://ly980408.github.io/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://ly980408.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://ly980408.github.io/tags/Hexo/"},{"name":"永久链接","slug":"永久链接","permalink":"https://ly980408.github.io/tags/%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5/"},{"name":"permalink","slug":"permalink","permalink":"https://ly980408.github.io/tags/permalink/"}]},{"title":"贪吃蛇？不，贪吃猫！","slug":"用原生-JS-写一个贪吃蛇","date":"2021-05-12T16:00:29.000Z","updated":"2023-11-23T07:09:13.277Z","comments":true,"path":"posts/2bb7f68c/","link":"","permalink":"https://ly980408.github.io/posts/2bb7f68c/","excerpt":"","text":"Greedy Snake 贪吃蛇基于原生 js，采用面向对象编程思想，部分 ES6+ 语法 效果展示演示地址 思路整理Classes 节点 Node: 用于创建蛇身体每一部分的组成元素，以及食物。 x: 水平位置y: 垂直位置type: head / body / foodel: 每个 node 实例都对应一个 DOM 元素，实际上就是一个个 div 小方块，每个方块在容器内部进行绝对定位，有对应的 top 和 left 值 蛇 Snake:存储蛇相关信息，处理移动等逻辑。 游戏 Game:用于存储游戏信息和控制游戏整体逻辑，初始化、开始、暂停、结束等。 核心原理 移动的实现： 关于蛇的移动的实现，我们不采用去修改每个元素对应的 top 和 left 的方法，因为当蛇达到一定长度时，每一步移动我们都要去修改很多 DOM 元素，这样做效率低而且性能也不好。 其实我们每次移动只需要考虑蛇头和蛇尾就可以了，当蛇移动时，生成一个新头，添加到身体最前端，然后弹出最后一个元素（即尾部），这样不断进行变化，就实现了蛇的移动；如果在移动过程中碰到了食物，则不需要删除当前蛇尾元素，这样则实现了蛇长度的增长。 食物的生成： while 循环获取容器内部随机的 x, y 值，当得到第一个不与蛇身体重合的位置时停下。 碰撞： 即两个 node 之间位置重合（碰到身体、食物）或者超出一定范围（碰到墙壁/出界），通过简单判断 x, y 即可实现。 代码实现详见源码: https://github.com/ly980408/GreedySnake","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/tags/JavaScript/"},{"name":"JS游戏","slug":"JS游戏","permalink":"https://ly980408.github.io/tags/JS%E6%B8%B8%E6%88%8F/"},{"name":"面向对象","slug":"面向对象","permalink":"https://ly980408.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"Vue 自定义指令实现 El-Select 选项懒加载","slug":"el-select懒加载","date":"2021-04-21T15:36:23.000Z","updated":"2023-11-23T07:09:13.276Z","comments":true,"path":"posts/f060dab1/","link":"","permalink":"https://ly980408.github.io/posts/f060dab1/","excerpt":"","text":"由于之前公司的项目中某个 select 选项数据量过大，想到了采用懒加载故从网上学到了这个方法，并用到了项目中，实测没什么问题，所以来分享一下很抱歉原文已经找不到了，如有侵权，请联系我删除 12345678910111213141516171819202122232425262728293031// 自定义指令实现 el-select 选项懒加载&lt;template&gt;&lt;el-select v-el-select-loadmore=&quot;loadMore&quot;&gt;&lt;!-- ... --&gt;&lt;/el-select&gt;&lt;/template&gt;&lt;script&gt; // ... directives: &#123; &#x27;el-select-loadmore&#x27;: &#123; bind (el, binding) &#123; const ElSelectWrap = el.querySelector( &#x27;.el-select-dropdown .el-select-dropdown__wrap&#x27; ) ElSelectWrap.addEventListener(&#x27;scroll&#x27;, function () &#123; const loadmore = this.scrollHeight - this.scrollTop &lt;= this.clientHeight if (loadmore) &#123; binding.value() &#125; &#125;) &#125; &#125; &#125;, methods: &#123; loadMore() &#123; // ... &#125; &#125;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://ly980408.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ly980408.github.io/tags/Vue/"},{"name":"自定义指令","slug":"自定义指令","permalink":"https://ly980408.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"},{"name":"el-select","slug":"el-select","permalink":"https://ly980408.github.io/tags/el-select/"},{"name":"懒加载","slug":"懒加载","permalink":"https://ly980408.github.io/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"}]},{"title":"JavaScript 基础知识总结","slug":"JavaScript-一些基础知识总结","date":"2021-03-29T16:14:17.000Z","updated":"2023-11-23T07:09:13.274Z","comments":true,"path":"posts/e5b43a6/","link":"","permalink":"https://ly980408.github.io/posts/e5b43a6/","excerpt":"","text":"文章内容为本人在最初学习 JS 时整理的笔记由于技术有限，知识点较为基础，也稍微有些杂乱如有错误，欢迎指出 输入输出123prompt(); //弹出输入框alert(); //弹出提示框console.log(); //浏览器控制台打印 变量声明、赋值和变量的初始化1234567var a; //声明a = 5; //赋值var b = 10; //初始化b = 20; //重新赋值var x = 1, y = 2, z = 3; //同时声明多个变量，可以只写一个var，中间用‘,’隔开 特殊情况 只声明 不赋值 -&gt; undefined 不声明 不赋值 -&gt; 使用时会报错 不声明直接赋值 -&gt; 可以使用 变量命名规范 由字母、数字、下划线、美元符号$组成 严格区分大小写 不能以数字开头 不能是关键字、保留字 变量名必须有意义 遵守驼峰命名法 数据类型typeof -&gt; 返回数据类型 基本数据类型 Number 数字 Boolean 布尔值 String 字符串 undefined 未定义 null 空值 （ES6 新增） Symbol 唯一标识符 引用数据类型 Object 对象 基本和引用类型的区别 JS 中的变量都是保存到栈内存中的 基本数据类型的值直接在栈内存中存储 值与值之间是独立存在的，修改一个变量不会影响其他变量 对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间 而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用，当通过一个变量修改属性时，另一个也会受到影响 当比较两个基本数据类型时，就是比较它们的值 当比较两个引用数据类型时，比较的是对象的内存地址 两个对象即使一模一样，如果地址不同，也会返回 false 数据类型转换 转换为字符串 变量.toString() String(变量) 强制转换 ‘+’拼接字符串(隐式转换，推荐) 转换为数字型 parseInt(string) 函数 将 string 类型转成整型 parseFloat(string) 函数 将 string 类型转成浮点型 Number() 强制转换函数 将 string 类型转成数字型 隐式转换 利用算术运算符隐式转换 转换为布尔型 Boolean() 函数：代表空、否定的值都会被转换为 false。 对象和函数对象的分类 内建对象 由 ES 标准中定义的对象，在任何 ES 的实现中都可以使用比如： Math String Number Boolean Function Object 宿主对象 由 JS 的运行环境提供的对象，目前来讲主要指由浏览器提供的对象比如 BOM DOM 自定义对象 由开发人员自己创建的对象 作用域 作用域指一个变量的作用范围 在 JS 中一共有两种作用域： 全局作用域 直接编写在 script 标签中的 JS 代码，都在全局作用域 全局作用域在页面打开时创建，在页面关闭时销毁 在全局作用域中有一个全局对象 window它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用 在全局作用域中：创建的变量都会作为 window 对象的属性保存创建的函数都会作为 window 对象的方法保存 全局作用域中的变量都是全局变量，在页面的任意部分都可以访问到 函数作用域 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁 没调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的 在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量 当在函数作用域中操作变量时，现在自身作用域中寻找，如果有就直接使用，没有则去上一级作用域中寻找 this解析器在调用函数时会向函数内部传递一个隐含的参数，这个隐含的参数就是 this， this 指向的是一个对象，这个对象我们称为为函数执行的上下文对象， 根据函数的调用方式的不同，this 会指向不同的对象， 主要有以下几个场景： 以函数的形式调用时，this 永远都是 window 以方法的形式调用时，this 就是调用方法的那个对象 以构造函数的形式调用时，this 就是新创建的那个对象 使用 call 和 apply 调用时，this 是传入的那个对象 构造函数构造函数本质上就是一个普通的函数，创建方式和普通函数没有区别 构造函数命名上习惯首字母大写 构造函数需要使用 new 关键字来调用 构造函数的执行流程： 立刻创建一个新的对象 将新建的对象设置为函数中的 this，在构造函数中可以使用 this 来引用新建的对象 逐行执行函数中的代码 将新建的对象作为返回值返回 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类 我们将通过一个函数创建的对象，称为是该类的实例 this 的情况： 当以函数的形式调用时，this就是window 当以方法的形式调用时，谁调用方法谁就是this 当以构造函数的形式调用时，this就是新创建的那个对象123456789101112131415161718192021222324252627282930313233343536373839404142/* 创建一个Person构造函数 * - 在Person构造函数中，为每一个对象都添加了一个sayName方法 * 目前我们是在构造函数内部创建方法，这就导致了构造函数每执行一次就会创建一个方法 * 而且所有实例的sayName方法都是一模一样的但却是唯一的 * - 我们完全可以使所有对象共享一个方法 */function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; /*this.sayName = function()&#123; alert(&quot;大家好，我是&quot;+this.name); &#125;;*/ //将sayName方法在全局作用域中定义，而不是在内部创建 this.sayName = fun;&#125;//将sayName方法在全局作用域中定义/* * 将函数定义在全局作用域，污染了全局作用域的命名空间 * 而且定义在全局作用域中也很不安全 * 解决：原型 */function fun() &#123; alert(&#x27;大家好，我是&#x27; + this.name);&#125;//创建Person类的实例var person1 = new Person(&#x27;李四&#x27;, 18, &#x27;男&#x27;);var person2 = new Person(&#x27;王五&#x27;, 16, &#x27;女&#x27;);person1.sayName();person2.sayName();//使用instanceof可以检查一个对象是否是一个类的实例//console.log(person1 instanceof Person); //true/* * 所有对象都是Object的后代 * 所以任何对象和Object作instanceof检查时都会返回true *///console.log(person1 instanceof Object); //true 原型 函数 prototype 属性 ==》 原型对象 （显式原型） ​ 在定义函数时自动添加的，默认值是一个空的 Object 实例对象(Object 例外) 实例 __proto__ 属性 ==》 原型对象 （隐式原型） ​ 在创建对象时自动添加的，默认值为构造函数的 prototype 属性值 ​ 即实例对象的隐式原型的值为其对应的构造函数显式原型的值 ​ 我们能直接操作显式原型，但不能操作隐式原型 原型对象 constructor 属性 ==》 函数对象 所有函数的 __proto__ 都是一样的(都是由构造函数 Function 创建的实例，包括 Function 本身） Object 的原型对象是原型链的尽头(Object.prototype.__proto__ == null) 12345678910111213141516171819202122232425262728293031323334353637/* * 原型prototype * 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype * 这个属性对应着一个对象，这个对象就是我们所谓的原型对象 * 如果函数作为普通函数调用prototype没有任何作用 * 当函数以创造函数的形式调用时，它所创建的对象中都会有一个隐含的属性 * 指向该构造函数的原型对象，我们可以通过__proto__来访问 * * 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到 * 我们可以将对象中共有的内容，统一设置到原型对象中 * * 当我们访问对象的属性或方法时，会现在对象自身中寻找，如果有则直接使用， * 没有则去原型中寻找... 直到找到Object的原型 * Object的原型没有原型(null)，如果在Object的原型中依然没有找到，则返回undefined * * 以后我们创建构造函数时，可以将这些对象共有的属性和方法，添加到构造函数的原型对象中 */function MyClass() &#123;&#125;//向MyClass的原型中添加属性aMyClass.prototype.a = 123;//向MyClass的原型中添加方法MyClass.prototype.sayHello = function () &#123; alert(&#x27;Hello&#x27;);&#125;;var mc = new MyClass();var mc2 = new MyClass();mc2.a = &#x27;我是mc2中的a&#x27;;//console.log(MyClass.prototype);//console.log(mc.__proto__ == MyClass.prototype); //trueconsole.log(mc.a); //123console.log(mc2.a); //我是mc2中的a 123456789101112131415function MyClass() &#123;&#125;//向MyClass的原型中添加属性nameMyClass.prototype.name = &#x27;我是原型中的名字&#x27;;var mc = new MyClass();mc.age = 18;//使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true//console.log(&quot;name&quot; in mc); //true//可以使用hasOwnProperty()来检查对象自身中是否有该属性//使用该方法只有当对象自身含有该属性时，才会返回trueconsole.log(mc.hasOwnProperty(&#x27;name&#x27;)); //falseconsole.log(mc.hasOwnProperty(&#x27;age&#x27;)); //true IIFEImmediately-Invoked Function Expression 立即调用函数表达式、 123456789//匿名函数自调用(function () &#123; console.log(&#x27;IIFE&#x27;);&#125;)();/* 作用： * 隐藏实现 * 不会污染外部命名空间 */ instanceof 表达式 A instanceof B 如果 B 函数的显式原型对象在 A 对象的原型链上，则返回 true 函数的方法123456789101112131415161718192021222324252627282930313233343536function fun() &#123; alert(this);&#125;/* * call()和apply() * - 这两个方法都是函数对象的方法，需要通过函数对象来调用 * - 当对函数调用call()和apply()都会调用函数执行 * - 在调用call()和apply()时可以将一个对象指定为第一个参数 * 这个对象将会成为函数执行时的this */fun; //[object window]fun.call(); //[object Object]fun.apply(); //[object Object]/*============================================== - call()方法可以将实参在对象之后依次传递 - apply()方法需要将实参封装到一个数组中统一传递 ==============================================*/function fun(a, b) &#123; console.log(&#x27;a = &#x27; + a); console.log(&#x27;b = &#x27; + b);&#125;var obj = &#123; name: &#x27;obj&#x27;, sayName: function () &#123; alert(this.name); &#125;,&#125;;fun.call(obj); //a = undefined b = undefinedfun.call(obj, 2, 3); //a = 2 b = 3fun.apply(obj, [2, 3]); this 的情况 以函数的形式调用时，this 永远都是 window 以方法的形式调用时，this 就是调用方法的那个对象 以构造函数的形式调用时，this 就是新创建的那个对象 使用 call 和 apply 调用时，this 是指的那个对象 arguments1234567891011/* * 在调用函数时，浏览器每次都会传递进两个隐含的参数： * 1.函数的上下文对线this * 2.封装实参的对象arguments * - arguments是一个类数组对象，它也可以通过索引来操作，也可以获取长度 * - 在调用函数时，我们所传递的参数都会在arguments中保存 * - arguments.length可以用来获取实参的数量 * - 即使不定义形参也可以通过arguments来使用实参 * - arguments里面有一个属性叫做callee * 这个属性对应的就是当前正在执行的函数对象 */ Date 对象123456789101112131415161718192021222324//创建一个Date对象//如果直接使用构造函数创建Date对象，则会封装为当前代码执行的时间var d = new Date();//创建一个指定的Date对象//需要在构造函数中传递一个表示时间的字符串作为参数//日期格式 月/日/年 时:分:秒var myDate = new Date(&#x27;12/25/2019 12:25:00&#x27;);console.log(myDate); //Wed Dec 25 2019 12:25:00 GMT+0800 (中国标准时间)/*========================================================= 方法： getDate() 获取一个月中的某一天(今天是几号? 1-31) getDay() 获取一周中的某一天(今天是周几? 0-6,0表示周日) getMonth() 获取一年中的某月(0-11) ... getTime() 获取当前日期对象的时间戳 - 时间戳：从格林威治时间的1970年1月1日 0分0时0秒 到当前日期的毫秒数 - 计算机底层保存时间使用的是时间戳=========================================================*/ Math 对象Math 和其他对象不同，它不是一个构造函数，它属于一个工具类，不用创建对象，它里面封装了数学运算相关的属性和方法 属性 E,LN2,LN10,PI … 方法 abs(),sqrt(),max(),min() … ceil() 向上取整 floor() 向下取整 round() 四舍五入 random() 生成一个 0-1 之间的随机数 12//生成一个x-y之间的随机数Math.round(Math.random() * (y - x) + x); 数组数组的四个常用方法push() 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新长度 可以将要添加的元素作为方法的参数传递，这些元素将会自动添加到数组的末尾 pop() 该方法可以删除数组的最后一个元素，并将被删除的元素返回 unshift() 向数组开头添加一个或多个元素，并返回新的数组长度 添加元素后，其他元素的索引会相应调整 shift() 可以删除数组的第一个元素，并将其作为返回值返回 数组的遍历 for 循环 12345var arr = [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;, &#x27;马六&#x27;];for (var i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]);&#125; forEach * 1234567891011121314151617//forEach() 不支持IE9以下浏览器var arr = [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;, &#x27;马六&#x27;];/* * forEach()方法需要一个函数作为参数 * - 像这种函数，由我们创建但不是我们调用的，我们称之为回调函数 * - 数组中有几个元素就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式 * 传递进来，我们可以定义形参，来读取这些内容 * - 浏览器会在回调函数中传递三个参数： * 第一个参数：当前正在遍历的元素 * 第二个参数：当前正在遍历的元素的索引 * 第三个参数：当前正在遍历的数组 */arr.forEach(function (value, index, obj) &#123; console.log(value);&#125;); slice()和 splice()slice() 可以用来从数组中提取指定元素 参数：截取开始的位置索引，截取结束的位置索引 (前闭后开,第二个参数可以不写，默认取到最后一个元素) 索引可以是负值 -1 为最后一个元素 splice() 删除元素并向数组添加新元素 将指定元素从原数组中删除并返回 参数：第一个：开始位置索引第二个：删除的数量第三个及以后：可以传递一些新的元素，这些元素会自动插入到开始索引位置之前 数组去重123456789101112131415161718192021//创建一个数组var arr = [1, 2, 3, 2, 1, 3, 4, 2, 5];//数组去重1//获取数组中的每一个元素（遍历）for (var i = 0; i &lt; arr.length; i++) &#123; //遍历当前元素后的所有元素 for (var j = i + 1; j &lt; arr.length; j++) &#123; //判断两个元素值是否相等 if (arr[i] == arr[j]) &#123; //相等则证明出现重复，删除j对应元素 arr.splice(j, 1); //当删除了当前j所对应元素后，后面的元素会自动补位 //导致j新对应的元素无法进行比较，如果该元素依旧重复则会遗漏 //故使j自减 j--; &#125; &#125;&#125;console.log(arr); 数组其他方法123456789101112131415161718192021222324252627282930313233343536/* 1 * concat()可以连接两个或多个数组，并将新的数组返回 * - 该方法不会对原数组产生影响 * - 参数也可以为元素 *//* 2 * join()方法可以将数组转换为一个字符串 * - 该方法不会对原数组产生影响，而是将转换后的结果返回 * - 可以指定一个字符串作为参数，它将会作为数组元素的连接符，不填则默认为&quot;,&quot; *//* 3 * reverse()方法可以用来反转数组 * - 会直接操作原数组 *//* 4 * sort()用来对数组元素进行排序 * - 改变原数组 * - 默认按照Unicode编码进行排序，即使对纯数字数组排序一会按照Unicode编码排序 * - 我们可以自己指定排序规则，在sort()添加一个回调函数 * 回调函数中需要定义两个形参 * 浏览器将会分别使用数组中的元素作为实参去调用回调函数 * - 浏览器会根据回调函数的返回值来决定元素的顺序 * 如果返回一个大于0的值，则元素交换位置 * 如果返回一个小于0的值，则元素位置不变 * 如果返回一个0，则认为两个元素相等，不交换位置 */var arr = [5, 4];arr.sort(function (a, b) &#123; return a - b; //升序 //return b - a; //降序&#125;); 包装类在 JS 中为我们提供了三个包装类，通过包装类可以将基本数据类型转换为对象 String() Number() Boolean() 但是我们在实际应用中不会使用基本数据类型的对象。 方法和属性只能添加给对象，不能添加给基本数据类型 当我们对一些基本数据类型去调用属性和方法时 浏览器会临时使用包装类将其转换为对象，然后再调用属性和方法 12345678var s = 123;s = s.toString(); //转换1s.hello = &#x27;你好&#x27;; //转换2//console.log(typeof s); //stringconsole.log(s.hello); //undefined //转换3 此时对象与转换2时不是同一个 字符串相关操作在底层字符串是以字符数组的形式保存的 length 属性：获取字符串长度 方法 charAt() 可以返回字符串指定位置的字符 charCodeAt() 返回指定位置字符的 Unicode 编码 String.fromCharCode() 可以根据字符编码获取字符 concat() 连接字符串 indexOf() ​ 检查一个字符串中是否含有指定内容，如果有则返回第一次出现的索引，没有则返回-1 ​ 可以指定第二个参数，表示开始查找的位置 lastIndexOf() 与从后往前找 slice() 从字符串中截取指定内容，同数组 slice()方法 substring() ​ 和 slice()类似，不同的是此方法参数不接受负值，传递负值则默认使用 0 ​ 还会自动调整参数位置，如果前大于后，则交换位置 split() ​ 可以将一个字符串拆分为一个数组 ​ 需要一个字符串作为参数，根据该字符串拆分数组 toUpperCase(), toLowerCase() 转大小写 正则表达式 创建正则表达式对象 语法：var 变量名 = new RegExp(“正则表达式”[,”匹配模式”]); 使用字面量来创建正则表达式 语法：var 变量名 = /正则表达式/匹配模式; 匹配模式： i 忽略大小写 g 全局匹配 正则表达式的方法： ​ test() 使用这个方法可以传入一个字符串来检查其是否符合正则表达式，返回布尔值 注意：使用构造函数创建正则表达式时，由于它的参数是一个字符串，而 \\ 是字符串中的转义字符，如果要使用 \\ 则需要使用 \\\\ 来代替 语法方括号用于查找某个范围内的字符 表达式 描述 [abc] 查找方括号之间的任何字符。 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [adgk] 查找给定集合内的任何字符。 [^adgk] 查找给定集合外的任何字符。 (red|blue|green) 查找任何指定的选项。 元字符元字符（Metacharacter）是拥有特殊含义的字符： 元字符 描述 . 查找单个字符，除了换行和行结束符。 \\w 查找单词字符。 \\W 查找非单词字符。 \\d 查找数字。 \\D 查找非数字字符。 \\s 查找空白字符。 \\S 查找非空白字符。 \\b 匹配单词边界。 \\B 匹配非单词边界。 \\0 查找 NUL 字符。 \\n 查找换行符。 \\f 查找换页符。 \\r 查找回车符。 \\t 查找制表符。 \\v 查找垂直制表符。 \\xxx 查找以八进制数 xxx 规定的字符。 \\xdd 查找以十六进制数 dd 规定的字符。 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 量词 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 n* 匹配任何包含零个或多个 n 的字符串。 n? 匹配任何包含零个或一个 n 的字符串。 n{X} 匹配包含 X 个 n 的序列的字符串。 n{X,Y} 匹配包含 X 至 Y 个 n 的序列的字符串。 n{X,} 匹配包含至少 X 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。 ?=n 匹配任何其后紧接指定字符串 n 的字符串。 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串。 字符串和正则表达式相关的方法 split() 可以将字符串拆分成一个数组 可以传递一个正则表达式作为参数 不需要设置全局匹配模式 search() 可以搜索字符串中是否含有指定内容 如果搜索到则返回第一次出现的索引，没有则返回-1 可以接收一个正则表达式作为参数 只会匹配第一个，即使设置了全局匹配模式 match() 可以根据正则表达式，将内容从字符串中提取出来 默认只会找到第一个符合要求的内容，我们可以设置全局匹配模式以匹配所有内容 该方法会将匹配到的内容封装到一个数组中返回，即使只有一个结果 replace() 可以将字符串中指定内容替换为新内容 参数：1.被替换内容(可以接收正则表达式) 2.新的内容 默认只会替换第一个匹配项 将新内容设置为空串可以用于删除指定内容","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/tags/JavaScript/"},{"name":"笔记","slug":"笔记","permalink":"https://ly980408.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"知识总结","slug":"知识总结","permalink":"https://ly980408.github.io/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"}]},{"title":"焕然一新的博客","slug":"焕然一新的博客","date":"2020-03-01T08:02:57.000Z","updated":"2023-11-23T07:09:13.276Z","comments":true,"path":"posts/b7541807/","link":"","permalink":"https://ly980408.github.io/posts/b7541807/","excerpt":"","text":"发现了一款甚合我意的主题 Butterfly 快速上手主题主题下载在你 hexo 根目录下执行这行代码： git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 更改设置安装完后修改根目录的配置文件_config.yml: 1theme: Butterfly 安装依赖 如果你没有 pug 和 stylus 渲染器，你需要先执行以下命令进行安装：​ npm install hexo-renderer-pug hexo-renderer-stylus ​ 如果你看见以下报错：​ Error: Cannot find module &#39;cheerio&#39;​ 需要安装cheerio，命令：​ npm install cheerio@0.22.0 --save 主题平滑升级为了主题的平滑升级,Butterfly 使用了 data files特性。 推荐把主题默认的配置文件_config.yml复制到 Hexo 工作目录下的source/_data/butterfly.yml，如果source/_data的目录不存在那就创建一个。 注意，如果你创建了butterfly.yml, 它将会替换主题默认配置文件_config.yml里的配置项 (不是合并而是替换), 之后你就只需要通过git pull的方式就可以平滑地升级 theme-butterfly了。 从3.3.0开始，以上方法不再支持 请改用以下方法，此方法只支持 Hexo 5.0.0 以上版本 如果已经在 source/_data/ 创建了 butterfly.yml，请记得删除掉。 把主題文件夹中的 _config.yml 复制到 Hexo 根目录，同时重新命名为 _config.butterfly.yml。 以后只需要在 _config.butterfly.yml 进行配置就行。 Hexo会自动合并 _config.yml 和 _config.butterfly.yml 里的配置，如果存在同名配置，会使用 _config.butterfly.yml 的配置，其优先级较高。 更多配置请查看Hexo和主题官方文档Butterfly 安裝文檔(一) 快速開始","categories":[{"name":"关于博客","slug":"关于博客","permalink":"https://ly980408.github.io/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://ly980408.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://ly980408.github.io/tags/Hexo/"},{"name":"Butterfly","slug":"Butterfly","permalink":"https://ly980408.github.io/tags/Butterfly/"}]},{"title":"JavaScript数组的方法","slug":"JavaScript数组的方法","date":"2020-02-18T14:50:33.000Z","updated":"2023-11-23T07:09:13.275Z","comments":true,"path":"posts/f6df6a5d/","link":"","permalink":"https://ly980408.github.io/posts/f6df6a5d/","excerpt":"数组数组的四个常用方法push() 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新长度 可以将要添加的元素作为方法的参数传递，这些元素将会自动添加到数组的末尾 pop() 该方法可以删除数组的最后一个元素，并将被删除的元素返回 unshift() 向数组开头添加一个或多个元素，并返回新的数组长度 添加元素后，其他元素的索引会相应调整 shift() 可以删除数组的第一个元素，并将其作为返回值返回","text":"数组数组的四个常用方法push() 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新长度 可以将要添加的元素作为方法的参数传递，这些元素将会自动添加到数组的末尾 pop() 该方法可以删除数组的最后一个元素，并将被删除的元素返回 unshift() 向数组开头添加一个或多个元素，并返回新的数组长度 添加元素后，其他元素的索引会相应调整 shift() 可以删除数组的第一个元素，并将其作为返回值返回 数组的遍历 for 循环 12345var arr = [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;, &#x27;马六&#x27;];for (var i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]);&#125; forEach * 1234567891011121314151617//forEach() 不支持IE9以下浏览器var arr = [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;, &#x27;马六&#x27;];/* * forEach()方法需要一个函数作为参数 * - 像这种函数，由我们创建但不是我们调用的，我们称之为回调函数 * - 数组中有几个元素就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式 * 传递进来，我们可以定义形参，来读取这些内容 * - 浏览器会在回调函数中传递三个参数： * 第一个参数：当前正在遍历的元素 * 第二个参数：当前正在遍历的元素的索引 * 第三个参数：当前正在遍历的数组 */arr.forEach(function (value, index, obj) &#123; console.log(value);&#125;); slice()和 splice()slice() 可以用来从数组中提取指定元素 参数：截取开始的位置索引，截取结束的位置索引 (前闭后开,第二个参数可以不写，默认取到最后一个元素) 索引可以是负值 -1 为最后一个元素 splice() 删除元素并向数组添加新元素 将指定元素从原数组中删除并返回 参数：第一个：开始位置索引第二个：删除的数量第三个及以后：可以传递一些新的元素，这些元素会自动插入到开始索引位置之前 数组去重123456789101112131415161718192021//创建一个数组var arr = [1, 2, 3, 2, 1, 3, 4, 2, 5];//数组去重1//获取数组中的每一个元素（遍历）for (var i = 0; i &lt; arr.length; i++) &#123; //遍历当前元素后的所有元素 for (var j = i + 1; j &lt; arr.length; j++) &#123; //判断两个元素值是否相等 if (arr[i] == arr[j]) &#123; //相等则证明出现重复，删除j对应元素 arr.splice(j, 1); //当删除了当前j所对应元素后，后面的元素会自动补位 //导致j新对应的元素无法进行比较，如果该元素依旧重复则会遗漏 //故使j自减 j--; &#125; &#125;&#125;console.log(arr); 数组其他方法123456789101112131415161718192021222324252627282930313233343536/* 1 * concat()可以连接两个或多个数组，并将新的数组返回 * - 该方法不会对原数组产生影响 * - 参数也可以为元素 *//* 2 * join()方法可以将数组转换为一个字符串 * - 该方法不会对原数组产生影响，而是将转换后的结果返回 * - 可以指定一个字符串作为参数，它将会作为数组元素的连接符，不填则默认为&quot;,&quot; *//* 3 * reverse()方法可以用来反转数组 * - 会直接操作原数组 *//* 4 * sort()用来对数组元素进行排序 * - 改变原数组 * - 默认按照Unicode编码进行排序，即使对纯数字数组排序一会按照Unicode编码排序 * - 我们可以自己指定排序规则，在sort()添加一个回调函数 * 回调函数中需要定义两个形参 * 浏览器将会分别使用数组中的元素作为实参去调用回调函数 * - 浏览器会根据回调函数的返回值来决定元素的顺序 * 如果返回一个大于0的值，则元素交换位置 * 如果返回一个小于0的值，则元素位置不变 * 如果返回一个0，则认为两个元素相等，不交换位置 */var arr = [5, 4, 1, 3, 2];arr.sort(function (a, b) &#123; return a - b; //升序 //return b - a; //降序&#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/tags/JavaScript/"}]},{"title":"甚至可以兼容IE8的JS事件绑定方法","slug":"JavaScript事件绑定问题","date":"2020-01-29T10:47:14.000Z","updated":"2023-11-23T07:09:13.275Z","comments":true,"path":"posts/aa38ac18/","link":"","permalink":"https://ly980408.github.io/posts/aa38ac18/","excerpt":"JavaScript 事件绑定常用方法 对象.事件 = 函数; 它只能同时为一个对象的一个事件绑定一个响应函数不能绑定多个，如果有多个，后面的会覆盖前面的 addEventListener() 此方法也可以为元素绑定响应函数 参数： 事件的字符串(不带 on) 回调函数，事件触发时执行 是否在捕获阶段触发事件，一般都传 false 使用此方法可以为一个元素的同一事件绑定多个响应函数 当事件触发时，按绑定顺序依次执行 attachEvent() IE8 及以下浏览器不支持 addEventListener()方法，但可以使用 attachEvent()方法起到同样的效果 参数: 事件字符串(带 on) 回调函数 此方法也可以绑定多个函数，不过函数执行顺序与 addEventListener()相反 this 问题与解决addEventListener()中的 this 是绑定事件的对象attachEvent()中的 this 是 window如果要解决兼容性问题则需要统一两个方法的 this这里我们用到了 call()方法call()可以用来改变函数的 this","text":"JavaScript 事件绑定常用方法 对象.事件 = 函数; 它只能同时为一个对象的一个事件绑定一个响应函数不能绑定多个，如果有多个，后面的会覆盖前面的 addEventListener() 此方法也可以为元素绑定响应函数 参数： 事件的字符串(不带 on) 回调函数，事件触发时执行 是否在捕获阶段触发事件，一般都传 false 使用此方法可以为一个元素的同一事件绑定多个响应函数 当事件触发时，按绑定顺序依次执行 attachEvent() IE8 及以下浏览器不支持 addEventListener()方法，但可以使用 attachEvent()方法起到同样的效果 参数: 事件字符串(带 on) 回调函数 此方法也可以绑定多个函数，不过函数执行顺序与 addEventListener()相反 this 问题与解决addEventListener()中的 this 是绑定事件的对象attachEvent()中的 this 是 window如果要解决兼容性问题则需要统一两个方法的 this这里我们用到了 call()方法call()可以用来改变函数的 this 函数 bind()自己定义一个函数用来给一个对象绑定事件 思路 三个参数：对象，事件，回调函数 兼容性： 通过 if 判断对象是否存在 addEventListener 方法来区分浏览器 this 问题的解决 由于传入的回调函数是浏览器调用的，我们无法去操作，所以我们在 attachEvent()不直接传入回调函数，而是先定义一个匿名函数，然后在函数内部调用回调函数，并利用 call 方法改变 this 示例代码1234567891011121314151617181920212223//定义一个函数bind()，用来为指定元素绑定事件响应函数/* * 参数： * obj 要绑定事件的对象 * eventStr 事件的字符串 * func 回调函数 */function bind(obj, eventStr, func) &#123; //判断是否有addEventListener()方法 if (obj.addEventListener) &#123; //大部分浏览器兼容的方式 obj.addEventListener(eventStr, func, false); &#125; else &#123; //IE8及以下 注意 on //obj.attachEvent(&quot;on&quot;+eventStr, func);//此方法this为window下面提供解决方法 //统一this 不直接调用func而是在匿名函数内调用 obj.attachEvent(&#x27;on&#x27; + eventStr, function () &#123; //在匿名函数内调用回调函数 利用call()方法将this改为obj func.call(obj); &#125;); &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/tags/JavaScript/"}]},{"title":"JavaScript构造函数","slug":"JavaScript构造函数学习笔记分享","date":"2020-01-12T07:06:47.000Z","updated":"2023-11-23T07:09:13.276Z","comments":true,"path":"posts/dd3a73b8/","link":"","permalink":"https://ly980408.github.io/posts/dd3a73b8/","excerpt":"构造函数构造函数就是一个普通的函数，创建方式和普通函数没有区别 不同的是构造函数名习惯上首字母大写 普通函数是直接调用，而构造函数需要使用new关键字来调用 构造函数的执行流程： 立刻创建一个新的对象 将新建的对象设置为函数中的 this（在构造函数中可以使用 this 来引用新建的对象） 逐行执行函数中的代码 将新建的对象作为返回值返回 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类 我们将通过一个函数创建的对象，称为是该类的实例","text":"构造函数构造函数就是一个普通的函数，创建方式和普通函数没有区别 不同的是构造函数名习惯上首字母大写 普通函数是直接调用，而构造函数需要使用new关键字来调用 构造函数的执行流程： 立刻创建一个新的对象 将新建的对象设置为函数中的 this（在构造函数中可以使用 this 来引用新建的对象） 逐行执行函数中的代码 将新建的对象作为返回值返回 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类 我们将通过一个函数创建的对象，称为是该类的实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 创建一个Person构造函数 * - 在Person构造函数中，为每一个对象都添加了一个sayName方法 * 目前我们是在构造函数内部创建方法，这就导致了构造函数每执行一次就会创建一个方法 * 而且所有实例的sayName方法都是一模一样的但却是唯一的 * - 我们完全可以使所有对象共享一个方法 */function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; //1.在构造函数内部添加方法 /*this.sayName = function()&#123; alert(&quot;大家好，我是&quot;+this.name); &#125;;*/ //this.sayName = fun; //2.将sayName方法在全局作用域中定义，而不是在构造函数内部&#125;//将sayName方法在全局作用域中定义/* * 将函数定义在全局作用域，污染了全局作用域的命名空间 * 而且定义在全局作用域中也很不安全 * 解决：原型 *///function fun()&#123;// alert(&quot;大家好，我是&quot;+this.name);//&#125;//3.向原型中添加sayName方法Person.prototype.sayName = function () &#123; alert(&#x27;大家好，我是&#x27; + this.name);&#125;;//创建Person类的实例var person1 = new Person(&#x27;李四&#x27;, 18, &#x27;男&#x27;);var person2 = new Person(&#x27;王五&#x27;, 16, &#x27;女&#x27;);person1.sayName();person2.sayName();//使用instanceof可以检查一个对象是否是一个类的实例//console.log(person1 instanceof Person); //true/* * 所有对象都是Object的后代 * 所以任何对象和Object作instanceof检查时都会返回true *///console.log(person1 instanceof Object); //true 原型12345678910111213141516171819202122232425262728293031323334353637/* * 原型prototype * 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype * 这个属性对应着一个对象，这个对象就是我们所谓的原型对象 * 如果函数作为普通函数调用prototype没有任何作用 * 当函数以创造函数的形式调用时，它所创建的对象中都会有一个隐含的属性 * 指向该构造函数的原型对象，我们可以通过__proto__来访问 * * 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到 * 我们可以将对象中共有的内容，统一设置到原型对象中 * * 当我们访问对象的属性或方法时，会现在对象自身中寻找，如果有则直接使用， * 没有则去原型中寻找... 直到找到Object的原型 * Object的原型没有原型(null)，如果在Object的原型中依然没有找到，则返回undefined * * 以后我们创建构造函数时，可以将这些对象共有的属性和方法，添加到构造函数的原型对象中 */function MyClass() &#123;&#125;//向MyClass的原型中添加属性aMyClass.prototype.a = 123;//向MyClass的原型中添加方法MyClass.prototype.sayHello = function () &#123; alert(&#x27;Hello&#x27;);&#125;;var mc = new MyClass();var mc2 = new MyClass();mc2.a = &#x27;我是mc2中的a&#x27;;//console.log(MyClass.prototype);//console.log(mc.__proto__ == MyClass.prototype); //trueconsole.log(mc.a); //123console.log(mc2.a); //我是mc2中的a 123456789101112131415function MyClass() &#123;&#125;//向MyClass的原型中添加属性nameMyClass.prototype.name = &#x27;我是原型中的名字&#x27;;var mc = new MyClass();mc.age = 18;//使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true//console.log(&quot;name&quot; in mc); //true//可以使用hasOwnProperty()来检查对象自身中是否有该属性//使用该方法只有当对象自身含有该属性时，才会返回trueconsole.log(mc.hasOwnProperty(&#x27;name&#x27;)); //falseconsole.log(mc.hasOwnProperty(&#x27;age&#x27;)); //true 原文地址：博客园 https://www.cnblogs.com/meow999/p/12059917.html","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/tags/JavaScript/"}]},{"title":"JavaScript DOM事件对象练习","slug":"JavaScriptDOM事件对象练习-学习内容分享","date":"2019-12-27T07:29:44.000Z","updated":"2023-11-23T07:09:13.275Z","comments":true,"path":"posts/5657d3d4/","link":"","permalink":"https://ly980408.github.io/posts/5657d3d4/","excerpt":"Event 对象Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。 事件通常与函数结合使用，函数不会在事件发生前被执行！ 本文用于记录个人学习过程中的两个小练习，其中包括一些事件对象的用法和问题的解决以及兼容性问题。 获取鼠标指针坐标 div 跟随鼠标移动","text":"Event 对象Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。 事件通常与函数结合使用，函数不会在事件发生前被执行！ 本文用于记录个人学习过程中的两个小练习，其中包括一些事件对象的用法和问题的解决以及兼容性问题。 获取鼠标指针坐标 div 跟随鼠标移动 练习1 获取鼠标指针坐标两个 div，当鼠标在上面的 div#areaDiv 移动时，在下面的 div#showMsg 中显示鼠标指针坐标 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #areaDiv&#123; width: 500px; height: 200px; border: 1px solid black; &#125; #showMsg&#123; width: 500px; height: 50px; margin-top: 20px; border: 1px solid black; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; /* * 当鼠标在areaDiv中移动时，在showMsg中显示鼠标的坐标 */ //获取div var areaDiv = document.getElementById(&quot;areaDiv&quot;); var showMsg = document.getElementById(&quot;showMsg&quot;); /* * 事件对象 * - 当事件的响应函数被触发时，浏览器会将一个事件对象作为实参传递进响应函数， * 在事件对象中封装了当前事件相关的一切信息，比如：鼠标指针的坐标，键盘哪个按键被按下 */ areaDiv.onmousemove = function(event)&#123; /* * 在IE8中，响应函数被触发时，浏览器不会传递事件对象 * 而是将事件对象作为window对象的属性保存的 window.event * 但此方法不兼容火狐 */ /*解决兼容问题，使用if判断 if(!event)&#123; event = window.event; &#125;*/ //此方法更简单方便 event = event || window.event; /* 获取坐标值 * clientX 可以获取鼠标指针的水平坐标 * clientY 可以获取鼠标指针的垂直坐标 */ var x = event.clientX; var y = event.clientY; //显示坐标值 showMsg.innerHTML = &#x27;x=&#x27;+x+&#x27; , y=&#x27;+y; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;areaDiv&quot;&gt;&lt;/div&gt; &lt;div id=&quot;showMsg&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2 div 跟随鼠标移动当鼠标在页面中移动时，使 div 跟随其移动 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;div跟随鼠标移动&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; width:2000px; height: 1000px;&#125; /*使页面出现滚动条*/ #box1&#123; width: 100px; height: 100px; background-color: red; position: absolute; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var box1 = document.getElementById(&quot;box1&quot;); //使div可以跟随鼠标移动，响应函数加给document document.onmousemove = function(event)&#123; event = event || window.event; //获取滚动条滚动距离 var st = document.documentElement.scrollTop; var sl = document.documentElement.scrollLeft; //获取鼠标指针坐标 /* clientX、clientY * 用于获取当前可见窗口的鼠标坐标 * 而div的偏移量是相对整个页面的 * * pageX、pageY可以获取鼠标相对当前页面的坐标 * 但是不兼容IE8及以下 * * 因此我们选择获取滚动条滚动距离，将其加到div的偏移量上 */ var left = event.clientX; var top = event.clientY; //设置div偏移量 box1.style.left = left +sl+&#x27;px&#x27;; box1.style.top = top +st+&#x27;px&#x27;; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 部分内容来源于网上教程，侵删。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/tags/JavaScript/"}]},{"title":"JavaScript 实现图片滚动","slug":"JavaScript-pic_move","date":"2019-12-10T13:13:14.000Z","updated":"2023-11-23T07:09:13.274Z","comments":true,"path":"posts/6d2ec284/","link":"","permalink":"https://ly980408.github.io/posts/6d2ec284/","excerpt":"定时器应用：图片滚动分享一下最近学习的 JavaScript 定时器实现图片的无缝滚动。 间隔型定时器setInterval()与 clearInterval() 12var timer = setInterval(func, delay); //第一个参数为定时器要执行的函数，第二个参数为定时器间隔，单位msclearInterval(timer); //停止定时器，参数为setInterval()所启动的定时器 原理和方法 让 ul 一直向左移动 –&gt; 减少 left 值 –&gt; offsetLeft 1oUl.style.left&#x3D;oUl.offsetLeft-1+&#39;px&#39;; 复制 li 我们演示的是 div 宽度可以容纳 4 张图片，而一共有 4 张图，所以我们要把 4 张图复制一份并接到后面 innerHTML 1oUl.innerHTML += oUl.innerHTML; 修改 ul 的 width 原先的 ul 宽度足以容纳内容，所以需要重新调整否则图片将分两行显示 1oUl.style.width = aLi[0].offsetWidth * aLi.length + &#x27;px&#x27;; 过界重设位置 当 ul 走完半程即第一份的 4 张图全部走出容器时，重设 ul 位置，回到起点，即可实现无缝滚动 判断: 123if (oUl.offsetLeft &lt; -oUl.offsetWidth / 2) &#123; oUl.style.left = &#x27;0&#x27;;&#125;","text":"定时器应用：图片滚动分享一下最近学习的 JavaScript 定时器实现图片的无缝滚动。 间隔型定时器setInterval()与 clearInterval() 12var timer = setInterval(func, delay); //第一个参数为定时器要执行的函数，第二个参数为定时器间隔，单位msclearInterval(timer); //停止定时器，参数为setInterval()所启动的定时器 原理和方法 让 ul 一直向左移动 –&gt; 减少 left 值 –&gt; offsetLeft 1oUl.style.left&#x3D;oUl.offsetLeft-1+&#39;px&#39;; 复制 li 我们演示的是 div 宽度可以容纳 4 张图片，而一共有 4 张图，所以我们要把 4 张图复制一份并接到后面 innerHTML 1oUl.innerHTML += oUl.innerHTML; 修改 ul 的 width 原先的 ul 宽度足以容纳内容，所以需要重新调整否则图片将分两行显示 1oUl.style.width = aLi[0].offsetWidth * aLi.length + &#x27;px&#x27;; 过界重设位置 当 ul 走完半程即第一份的 4 张图全部走出容器时，重设 ul 位置，回到起点，即可实现无缝滚动 判断: 123if (oUl.offsetLeft &lt; -oUl.offsetWidth / 2) &#123; oUl.style.left = &#x27;0&#x27;;&#125; 图片演示 此图为初始结构示意 外层为 div 容器，内部为 ul 图片列表，4 张图片，则设置 div 宽度等于图片宽度*4 如图，当 ul 向左移动后右侧没有内容进行显示，故我们进行复制 li 操作 （外层容器 div 设置 overflow:hidden;属性，已经走出 div 范围的部分不会显示） 复制 li 后再进行移动则会产生如图所示效果（两侧超出内容隐藏） 当 ul 走完一半宽度（如图），此时显示内容原始内容相同，故我们重设 ul 位置，在视觉上实现无缝滚动 重设 ul 位置，回到初始状态 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;图片滚动&lt;/title&gt; &lt;style&gt; #div1 &#123; position: relative; width: 1200px; height: 437px; margin: 100px auto; overflow: hidden; border-radius: 15px; &#125; .pic-list &#123; position: absolute; left: 0; top: 0; &#125; .pic-list li &#123; float: left; width: 300px; height: 437px; list-style: none; &#125; .pic-list img &#123; width: 300px; height: 437px; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; var oDiv = document.getElementById(&#x27;div1&#x27;); var oUl = oDiv.getElementsByClassName(&#x27;pic-list&#x27;); var aLi = oUl.getElementsByTagName(&#x27;li&#x27;); oUl.innerHTML += oUl.innerHTML; //将图片列表复制一份接到后面，长度必须大于等于div一次可显示长度 oUl.style.width = aLi[0].offsetWidth * aLi.length + &#x27;px&#x27;; //重新设置ul宽度=一个li宽度*li个数 //图片滚动函数 function move() &#123; //if条件判断作用： //当ul走完一半的时候重新回到原点，即可实现无缝滚动 if (oUl.offsetLeft &lt; -oUl.offsetWidth / 2) &#123; oUl.style.left = &#x27;0&#x27;; &#125; oUl.style.left = oUl.offsetLeft - 1 + &#x27;px&#x27;; //每单位时间往左移动1px &#125; var timer = setInterval(move, 30); //设置定时器，间隔30ms oDiv.onmouseover = function () &#123; //鼠标移入停止滚动 clearInterval(timer); &#125;; oDiv.onmouseout = function () &#123; //鼠标移出开始滚动 timer = setInterval(move, 30); &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;ul class=&quot;pic-list&quot;&gt; &lt;li&gt;&lt;img src=&quot;img/1.jpg&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/2.jpg&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/3.jpg&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/4.jpg&quot; /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 小结这是之前学习的利用原生 JS 定时器制作图片滚动效果，比较基础，做一下记录总结 初学前端，小白一枚，有问题还望指正 欢迎志同道合的小伙伴与我交流 o(￣ ▽ ￣)ブ","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/tags/JavaScript/"}]},{"title":"Hexo+Github个人博客搭建详细教程","slug":"Hexo-Github_blog","date":"2019-12-05T08:54:34.000Z","updated":"2023-11-23T07:09:13.273Z","comments":true,"path":"posts/acf3d1d8/","link":"","permalink":"https://ly980408.github.io/posts/acf3d1d8/","excerpt":"概述使用Hexo搭建个人博客并利用GitHub进行部署。 很久之前就想搭建一个博客，可是也一直没有行动，最近在逛B站的时候发现一个up主（CodeSheep）的一个视频 《手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo》: https://www.bilibili.com/video/av44544186/ ，哈哈哈哈哈给他免费打个广告（虽然根本没人能看到），简直就是保姆级的教学视频，良心up主啊，真·手把手教学，大体浏览了一下以后我就坐不住了，马上起来开电脑行动！ 那在这里就简单总结一下过程和遇到的坑吧","text":"概述使用Hexo搭建个人博客并利用GitHub进行部署。 很久之前就想搭建一个博客，可是也一直没有行动，最近在逛B站的时候发现一个up主（CodeSheep）的一个视频 《手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo》: https://www.bilibili.com/video/av44544186/ ，哈哈哈哈哈给他免费打个广告（虽然根本没人能看到），简直就是保姆级的教学视频，良心up主啊，真·手把手教学，大体浏览了一下以后我就坐不住了，马上起来开电脑行动！ 那在这里就简单总结一下过程和遇到的坑吧 搭建博客博客是基于Hexo搭建的，需要Node.js、Git等支持 我用的是windows系统，而up主是在MacOS系统下操作的，其实大同小异。 安装Node.js 搜索引擎搜索Node.js或者直接访问 https://nodejs.org 下载左边那个LTS版本 下载完成后安装，使用 Node.js 官方安装程序时，请确保勾选 Add to PATH 选项（默认已勾选） 在cmd下分别输入命令行node -v和npm -v检查是否安装成功 安装Git 搜索引擎搜索git或者直接访问 https://git-scm.com/downloads 选择对应的操作系统下载 安装（在桌面或任意文件夹下右键菜单如果出现‘Git Bash Here’则说明成功） 安装cnpm（可选）由于国内镜像源速度较慢，所以先利用npm下载cnpm 在cmd中执行以下命令： npm install -g cnpm --registry=https://registry.npm.taobao.org 安装Hexo用以下命令安装hexo（没有安装cnpm则换成npm即可）： cnpm install -g hexo-cli 完成后运行hexo -v 查看版本以检查是否安装成功 开始搭建博客创建一个文件夹，例如：D:\\blog 转到此路径，然后运行hexo init进行初始化，也可以直接用hexo init D:\\blog 看到INFO Start blogging with Hexo!则说明成功 此时你会发现对应目录下已经为你自动生成了一些文件 12345678910111213C:\\WINDOWS\\system32&gt;d:D:\\&gt;cd blogD:\\blog&gt;D:\\blog&gt;hexo init或者直接C:\\WINDOWS\\system32&gt;hexo init D:\\blog...INFO Start blogging with Hexo!D:\\blog&gt; 启动只需要hexo server或者直接简写hexo s即可启动 123D:\\blog&gt;hexo sINFO Start processingINFO Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop. 看到以上提示说明启动成功，然后打开浏览器访问 http://localhost:4000 即可看到博客页面 新建文章用hexo new &quot;My New Post&quot;新建博客文章 12D:\\blog&gt;hexo new &quot;我的第一篇博客文章&quot;INFO Created: D:\\blog\\source\\_posts\\我的第一篇博客文章.md 可以看到生成的文件是.md后缀即markdown格式，你需要了解一下markdown 生成静态文件hexo generate或者hexo g 生成静态文件。 hexo s 重新启动服务器即可看到新添加的文章了。 部署博客这里我们用利用Github将博客进行免费部署。 创建Github库首先你需要有一个Github账号，然后新建一个库，库的名字为：username.github.io 注意此处username必须为你的用户名！ 安装部署插件 cnpm install --save hexo-deployer-git 更改配置文件在你的目录找到名为_config.yml的文件，用文本编辑器打开文件，找到最下面的‘deploy’项，将内容改为如下： 1234deploy: type: git repo: https://github.com/username/username.githu.io.git # 或者SSH branch: master 进行部署命令很简单只需要一行 hexo d 即可，过程会提示你输入你的 Github 的账号密码，正确输入即可。 成功提示 INFO Deployer done: git 然后刷新你的仓库你会发现多了很多东西 访问博客地址部署完成后访问username.github.io 如果出问题的话将 Git 与 Github 的用户名改为一致后重试 1234567891011查看用户名和邮箱地址：git config user.namegit config user.email修改用户名和邮箱地址:git config --global user.name &quot;xxxx&quot;git config --global user.email &quot;xxxx&quot; 更换主题请看这篇文章：焕然一新的博客","categories":[{"name":"关于博客","slug":"关于博客","permalink":"https://ly980408.github.io/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://ly980408.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://ly980408.github.io/tags/Hexo/"}]}],"categories":[{"name":"React","slug":"React","permalink":"https://ly980408.github.io/categories/React/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/categories/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://ly980408.github.io/categories/Vue/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://ly980408.github.io/categories/Leetcode/"},{"name":"关于博客","slug":"关于博客","permalink":"https://ly980408.github.io/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"指南","slug":"指南","permalink":"https://ly980408.github.io/tags/%E6%8C%87%E5%8D%97/"},{"name":"React","slug":"React","permalink":"https://ly980408.github.io/tags/React/"},{"name":"最佳实践","slug":"最佳实践","permalink":"https://ly980408.github.io/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://ly980408.github.io/tags/JavaScript/"},{"name":"vite","slug":"vite","permalink":"https://ly980408.github.io/tags/vite/"},{"name":"vue","slug":"vue","permalink":"https://ly980408.github.io/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"https://ly980408.github.io/tags/webpack/"},{"name":"wordle","slug":"wordle","permalink":"https://ly980408.github.io/tags/wordle/"},{"name":"game","slug":"game","permalink":"https://ly980408.github.io/tags/game/"},{"name":"算法","slug":"算法","permalink":"https://ly980408.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://ly980408.github.io/tags/leetcode/"},{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"https://ly980408.github.io/tags/JavaScirpt/"},{"name":"ES6","slug":"ES6","permalink":"https://ly980408.github.io/tags/ES6/"},{"name":"博客","slug":"博客","permalink":"https://ly980408.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://ly980408.github.io/tags/Hexo/"},{"name":"永久链接","slug":"永久链接","permalink":"https://ly980408.github.io/tags/%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5/"},{"name":"permalink","slug":"permalink","permalink":"https://ly980408.github.io/tags/permalink/"},{"name":"JS游戏","slug":"JS游戏","permalink":"https://ly980408.github.io/tags/JS%E6%B8%B8%E6%88%8F/"},{"name":"面向对象","slug":"面向对象","permalink":"https://ly980408.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"Vue","slug":"Vue","permalink":"https://ly980408.github.io/tags/Vue/"},{"name":"自定义指令","slug":"自定义指令","permalink":"https://ly980408.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"},{"name":"el-select","slug":"el-select","permalink":"https://ly980408.github.io/tags/el-select/"},{"name":"懒加载","slug":"懒加载","permalink":"https://ly980408.github.io/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"name":"笔记","slug":"笔记","permalink":"https://ly980408.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"知识总结","slug":"知识总结","permalink":"https://ly980408.github.io/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"name":"Butterfly","slug":"Butterfly","permalink":"https://ly980408.github.io/tags/Butterfly/"}]}